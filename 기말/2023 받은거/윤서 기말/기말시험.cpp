//-----------------------------------------------------------------------------
// 기말시험.cpp 
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// 컴퓨터에 살고 있는 Monster를 class로 모델링해서 다형성을 구현해 본다.
//-----------------------------------------------------------------------------
// 부모 클래스는 Monster이고  3종의 자식 Monster 클래스가 있다.
//
// 자식 Monster는 다음과 같은 특수기를 발휘할 수 있다.
//
// TimeMonster		- mSec 만큼 CPU를 정지시킨다.
// MemoryMonster	- 할당한 num개 메모리의 각 바이트값을 1 증가시킨다.
// ScreenMonster	- 랜덤 알파벳 문자 n개를 화면에 출력한다.
//-----------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <fstream>
#include "TimeMonster.h"
#include "MemoryMonster.h"
#include "ScreenMonster.h"
using namespace std;

extern default_random_engine dre;


//---------
int main( )
//---------
{
	// Monster를 생성할 때 사용할 랜덤값
	uniform_int_distribution<> uiTime{ 99, 499 };
	uniform_int_distribution<> uiMemory{ 2, 29 };
	uniform_int_distribution<> uiScreen{ 12, 60 };
	uniform_int_distribution<> uiThree{ 0, 2 };


	// 문제의 그림과 같이 프로젝트를 만들었다면 다음 코드가 문제없이 실행될 것이다. 
	// 실행시켜 보자.
	// [생성 예] 자식 Monster를 생성할 때 생성자의 인자로 랜덤값을 주어 생성한다.
	{
		// 각 자식 Monster를 한 개 생성하였다
		MemoryMonster memoryMonster( uiMemory( dre ) );
		ScreenMonster screenMonster( uiScreen( dre ) );
		TimeMonster timeMonster( uiTime( dre ) );

		// 생성한 Monster의 special 멤버를 호출하였다
		// 화면 출력결과는 옆의 주석문과 같다. - 결과 값이 다를 수도 있다.
	
		memoryMonster.special( );		// [1] : 모든 int 값 1증가
		screenMonster.special( );		// [2] : 문자-- > FyNdBXqzKNtKiYDppMCvLcNkblxKRxlDgmKdrehmHPs
		screenMonster.special( );		// [2] : 문자-- > aHcezVmbZNxkOAobluYziGboaICFsezSBJsbAtNefXr
		timeMonster.special( );			// [3] : CPU 정지 - 426ms

		cout << '\n';
		cout << "MemoryMonster의 메모리 값을 출력해 보았다" << '\n';
		memoryMonster.show( );			// 메모리 값 출력, MemoryMonster의 값은 따로 출력해 볼 수도 있다.
	}




	//-----------------------------------------------------------------------------------
	// 파일 "자료1.txt"에는 몇 개인지 모르는 int값이 기록되어 있다.
	// 파일을 한 번만 읽어 끝자리가 1인 int(38541, 2931과 같이 1의 자리가 1인)의 개수만큼 
	// Monster를 생성하여 관리하려 한다.
	//-----------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------
	// [문제 1] "자료1.txt"에서 끝자리가 1인 int는 모두 몇 개인지 찾아 
	// 화면에 출력하는 코드를 작성하고 출력된 개수도 답안지에 적어라.	(코드 15, 개수 5)  
	//-----------------------------------------------------------------------------------

	ifstream in{ "자료1.txt" };
	if (not in) {
		cout << "파일을 열 수 없습니다" << '\n';
		return 0;
	}

	int num{ };							// 끝자리가 1인 int의 개수를 여기에 저장하자

	// 여기에 들어갈 코드를 작성하라. (코드 15, 화면에 출력된 개수 5)
	int result{};
	while (in >> result) {
		if (result % 10 == 1) {
			++num;
		}
	}

	// 87개

	//----------------------------------------------------------------------------
	// [문제 1]을 해결하지 못했다면 num = 100 이라고 놓고 다음 문제를 풀어 나가자.
	//----------------------------------------------------------------------------

	// num = 100;						// 출력 예시는 100으로 놓고 문제를 푼 결과임
	// num = 100;						// [문제 1] 미해결 시 주석을 제거하자
										// 답지에 num = 100으로 놓고 풀었다고 적어 놓자

	cout << '\n';
	cout << "-------------------------------------" << '\n';
	cout << "관리하는 Monster 객체의 수 - " << num << '\n';
	cout << "-------------------------------------" << '\n';
	cout << '\n';


	//---------------------------------------------------------------------------
	// 다수의 자식 Monster 객체를 활용할 수 있는 다형성 구현 프로그램을 작성한다.
	//---------------------------------------------------------------------------

	//--------------------------------------------------------------------
	// [문제 2] Monster 객체 num개를 관리할 수 있는 메모리를 만들어라.		
	// (이 메모리를 사용하여 다형성을 구현할 것이다)
	// 만든 메모리를 답과 같은 영역에 만든 이유를 적어라. (코드 5, 이유 5)
	//--------------------------------------------------------------------


	// 여기에 들어갈 코드와 이유를 답지에 적어라. (코드 5, 이유 5)	
	Monster** monsters = new Monster * [num];

	// 이유 : monster는 부모 객체이기 때문에 monster에 num만큼 넣어주고, num의 개수가 몇개인지 모르기 때문에 동적할당을 통해
	// free store에 저장합니다.



	//--------------------------------------------------------------------------------------------------
	// [문제 3] [문제 2]에서 만든 메모리를 다음과 같은 생성 규칙에 따라 Monster를 생성하여 채워라.	(20)
	//--------------------------------------------------------------------------------------------------

	//--------------------------------------------------------------------------------------
	// Monster 생성 규칙
	//--------------------------------------------------------------------------------------
	// 값이 0, 1, 2인 주사위를 던진다. ( uiThree(dre)를 호출하면 됨 )
	//
	//		주사위의 값이 0 이면
	//			TimeMonster 
	//		주사위의 값이 1 이면
	//			MemoryMonster
	//		주사위의 값이 2 이면
	//			ScreenMonster
	// 
	//   를 main 함수 시작부분에 있는 [생성 예]와 같은 방법으로 생성한다.
	//
	// - 생성결과는 [문제 4]의 출력화면 예시를 참고하라,
	//--------------------------------------------------------------------------------------


	for (int i = 0; i < num; ++i) {
		int sel = uiThree( dre );		// 주사위를 던졌다

		// 여기에 들어갈 코드를 답지에 적으면 된다. (20)	
		switch (sel) {
		case 0: 
			monsters[i] = new TimeMonster(uiTime(dre));
			break;
		case 1:
			monsters[i] = new MemoryMonster(uiMemory(dre));
			break;
		case 2:
			monsters[i] = new ScreenMonster(uiScreen(dre));
			break;
		default:
			break;
		}

	}


	//--------------------------------------------------------------------------------------
	// [문제 4] 생성한 모든 Monster의 special()을 호출하여 다형성이 구현됨을 확인하라.	(10)
	// - 다운받은 출력화면 예시를 참고하라,
	//--------------------------------------------------------------------------------------

	cout << '\n';
	cout << "-------------------------------------" << '\n';
	cout << "[문제 4] special() 멤버를 호출한 결과" << '\n';
	cout << "-------------------------------------" << '\n';

	// 여기에 들어갈 코드를 답지에 적어라. (10)	
	for (int i = 0; i < num; ++i)
		monsters[i]->special();



	//------------------------------------------------------------------------------
	// [문제 5] 관리하는 몬스터를 id값 기준 내림차순으로 qsort 함수로 정렬하라.	(30)
	//------------------------------------------------------------------------------


	// 여기에 들어갈 qsort 코드를 답지에 적어라. (30)	

	qsort(monsters, num, sizeof(Monster*), [](const void* a, const void* b) {
		const Monster* monsterA = *static_cast<const Monster* const*>(a);
		const Monster* monsterB = *static_cast<const Monster* const*>(b);

		// 내림차순 정렬
		return monsterB->getId() - monsterA->getId();
	});
	

	cout << '\n';
	cout << "------------------------------------------------" << '\n';
	cout << "[문제 5] qsort() 후 special() 멤버를 호출한 결과" << '\n';
	cout << "------------------------------------------------" << '\n';

	// 여기에서 special()을 호출하는 코드는 의도에 따라 보이지 않는다.

	for (int i = 0; i < num; ++i) {
		monsters[i]->special();
	}

	//--------------------------------------------------------------------------------
	// 전체 num개의 Monster 중 MemoryMonster는 확보한 메모리에 모두 1을 저장하고 있다.
	// MemoryMonster의 special 함수를 한 번 호출할 때 마다 저장된 값은 1 증가한다.
	// 이 동작은 ++ 연산을 사용하는 것이 더 자연스럽다.
	//--------------------------------------------------------------------------------

	// [문제 6] 관리하는 Monster 중 모든 MemoryMonster를 ++(pre-increment)하라.	(관련 코드 20)
	// MemoryMonster.h와 MemoryMonster.cpp에 추가한 코드도 답지에 적어라.

	cout << '\n';
	cout << " < ++MemoryMonster >" << '\n';
	cout << '\n';

	// 여기에 들어갈 코드를 적어라. (20)

	for (int i = 0; i < num; ++i) {
    if (MemoryMonster* memoryMonster = dynamic_cast<MemoryMonster*>(monsters[i])) {
        ++(*memoryMonster); // 이 부분 수정
		}
	}

	// 관리하는 num개 Monster 중에서 MemoryMonster의 show() 멤버를 호출한 결과는 출력화면 예시를 참고하라.

	cout << '\n';
	cout << "-------------------------------------------------------" << '\n';
	cout << "[문제 6] 이후 MemoryMonster의 show() 멤버를 호출한 결과" << '\n';
	cout << "-------------------------------------------------------" << '\n';

	// 여기에서 show()를 호출하는 코드는 의도에 따라 보이지 않는다.

	for (int i = 0; i < num; ++i) {
		if (MemoryMonster* memoryMonster = dynamic_cast<MemoryMonster*>(monsters[i])) {
			memoryMonster->show();
		}
	}

	//-------------------------------------------------------------------------------------------------
	// [문제 7] 관리하는 num개의 Monster 중 첫째 Monster를 지워 모두 num-1개의 Monster로 만들려고 한다.
	// 출력결과 예시와 같이 출력될 수 있도록 첫째 Monster를 지우고 메모리를 정리하라.			   (30)
	//-------------------------------------------------------------------------------------------------

	cout << '\n';
	cout << "------------------------------------------------------------------" << '\n';
	cout << "[문제 7] 첫째 Monster를 삭제하고 나서 special() 멤버를 호출한 결과" << '\n';
	cout << "------------------------------------------------------------------" << '\n';


	// 여기에 들어갈 코드를 답지에 적어라. (30)	

	delete monsters[0];
	// 첫 번째 Monster를 삭제한 후, 나머지 Monster를 한 칸씩 당겨줌
	for (int i = 0; i < num - 1; ++i) {
		monsters[i] = monsters[i + 1];
	}
	// 배열 크기를 감소시킴
	--num;
	

	// 여기에 있을 special() 멤버 호출 코드는 의도에 따라 보이지 않는다.
	for (int i = 0; i < num; ++i) {
		monsters[i]->special();
	}
}

