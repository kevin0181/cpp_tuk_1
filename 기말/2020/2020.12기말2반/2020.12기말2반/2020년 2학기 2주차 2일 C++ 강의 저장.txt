




//-------------------------------------------------------------------------
[ 2주차 2일.cpp ] - 2020-09-16 오후 10:10:06 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                               (2주 2일)

시험 1 9월 28일(월요일) 예정 - 시험범위 따로 없음
*/
//-------------------------------------------------------------------------


#include <iostream>
#include "save.h"

// [실습] 정수 n의 값을 화면에 출력하시오.

int n; // [00000000][00000000][00000000][00000000]
// main함수 이전에 쓰는 int는 모든 비트를 0으로 채우라는 명령어.

int main()
{
	std::cout << n << '\n';

	save("2주차 2일.cpp");

}





//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-09-16 오후 10:12:45 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                               (2주 2일)

시험 1 9월 28일(월요일) 예정 - 시험범위 따로 없음
*/
//-------------------------------------------------------------------------


#include <iostream>
#include "save.h"

// [문제] 다음 main()이 문제없이 실행되게 코딩하라.
// main()이 변경되면 안 된다.
// Player는 사용자가 만든 자료형이어야 한다. = char, int, double과 같은 자료형이면 안 된다.

// #define Player int
// using Player = int; // Cpp에서는 이런식으로 씀. 꼭 이렇게 쓰기.
struct Player { // 구조체 사용자 정의
	char x[3];
};

int main()
{
	int n;
	Player mario;

	std::cout << sizeof(mario) << '\n'; // mario의 크기를 알아보는 방법. sizeof 기억하기.

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-09-16 오후 10:13:54 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                               (2주 2일)

시험 1 9월 28일(월요일) 예정 - 시험범위 따로 없음
*/
//-------------------------------------------------------------------------


#include <iostream>
#include "save.h"

// [문제] 다음 main()이 문제없이 실행되게 코딩하라.
// main()이 변경되면 안 된다.
// Player는 사용자가 만든 자료형이어야 한다. = char, int, double과 같은 자료형이면 안 된다.

// #define Player int
// using Player = int; // Cpp에서는 이런식으로 씀. 꼭 이렇게 쓰기.
struct Player { // 구조체 사용자 정의
};
// 구조체에 크기 지정 안 하면 1바이트로 나옴. 

int main()
{
	int n;
	Player mario;

	std::cout << sizeof(mario) << '\n'; // mario의 크기를 알아보는 방법. sizeof 기억하기.

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-09-16 오후 10:23:37 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                               (2주 2일)

주사위를  굴리는 프로그램 작성하고
랜덤 넘버를 만드는 방법을 알아본다. 

[다음시간] 변수값의 교환과 레퍼런스*/
//-------------------------------------------------------------------------


#include <iostream>
#include "save.h"
#include <random>
// [실습] 주사위 프로그램을 만들어 본다.

int main()
{
	std::cout << "주사위 프로그램입니다. \n\n";

	std::cout << "글자를 누르면 주사위를 굴립니다. ";
	char c;
	std::cin >> c;

	// [할 일] 1~6의 수 중 하나를 화면에 출력해 줘야 할 텐데...
	std::cout << "주사위의 수는 " << rand() % 6 + 1 << '\n'; 

	save("소스.cpp"); // 결과가 6으로만 계속 나옴.
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-09-16 오후 10:45:33 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                               (2주 2일)

주사위를  굴리는 프로그램 작성하고
랜덤 넘버를 만드는 방법을 알아본다. 

[다음시간] 변수값의 교환과 레퍼런스
랜덤 설명 다시할 것*/
//-------------------------------------------------------------------------


#include <iostream>
#include <random> // 다음 시간에 랜덤 설명할 것
#include <thread> // 시간 함수
#include <chrono> // 시간 함수
#include "save.h"

// [실습] 주사위 프로그램을 만들어 본다.

int main()
{
	save("소스.cpp");

	using namespace std::chrono;
	std::default_random_engine dre;
	std::uniform_int_distribution<> uid;

	for (;;) {
		std::cout << "rand()의 결과 " << uid(dre) << '\n'; // uid(dre) = rand() 같은 것은데 현대에는 uid로 씀
		std::this_thread::sleep_for(333ms); // 1초에 3개 정도 넘어가도록 함
	}
}





//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-10-05 오후 2:17:14 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                               (5주 1일)

시험 문제 풀이 */

//-------------------------------------------------------------------------


#include <iostream>
using namespace std;
#include "save.h"

// [문제 1] 프로그램의 출력을 확인하고 이유를 설명하라.
/*
int main()
{
	int a{ 0B0101'0101'0101'0101'0101'0101'01010'0101 };
	cout << static_cast<char>(a) << endl;

	save("소스.cpp");

}
[답] : int는 4바이트, char는 1바이트. int형이 char로 변경되면서 하위 
1바이트만 char형으로 들어가서 이에 해당되는 아스키코드 85번째의 값이 U가 나온다. 





// [문제 2] 아래 main 함수를 구동하면 무슨 값이 나올지 예상하고 이유를 써라.

int main()
{
	char a{ 'O' };
	char z{ 'K' };
	change(a, z);

	cout << a << z << " ! " << endl; // OK !

	save("소스.cpp");

}

// 이유 : change 함수는 변경할 수 없음. 원격조종. C++에서는 값이 OK로 나옴. */





// [문제 3] 두 정수의 값을 오름차순으로 바꾸는 함수 order를 선언하고 정의하라.
// main을 바꾸면 안 된다.

/*
void order(int&, int&); // 선언

void order(int& x, int& y) // 정의
{
	if (x > y) {
		int temp = x;
		x = y;
		y = temp;
	}
}

int main()
{
	int a{ 2 }, b{ 1 }, c{ 3 };

	order(a, b);
	order(b, c);

	cout << a << ", " << b << ", " << c << endl;

	save("소스.cpp");
} */





// [문제 4] 주사위를 10'000번 던져서 각 숫자가 나온 확률을 화면에 출력하라. 
// 가장 확률이 높은 수를 찾아 화면에 출력된 그대로 답안지에 써라
// ( 출력 예 : 1의 확률 - 0.151 )

#include "random"

int main()
{
	discrete_distribution<> dd{ 0, 3, 1, 5, 6, 4, 2 };
	default_random_engine dre{ 2020182032 };

	// 여기에 들어갈 코드를 답안지에 적는다.

	int num[6] { 0 }; // 0으로 초기화 꼭 해야 됨.

	for (int i = 0; i < 10'000; ++i)
		num[dd(dre) - 1] ++;

	for (int i = 0; i < 6; ++i)
		cout << i + 1 << "의 확률 - " << num[i]/10'000.f << endl;

	save("소스.cpp");
}





//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-10-05 오후 2:48:02 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                               (5주 1일)

값을 정렬해본다. 버블 정렬.
처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다. 
STACK, DATA, HEPA(Free Store), CODE */

//-------------------------------------------------------------------------

// [문제] 문장을 오름차순으로 정렬하여 출력하라.
// (의문) 내림차순으로 정렬할 수는 없을까?

#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std;

int main()
{
	char str[] = "The qiuck brown fox jumps over the lazy dog"; //NULL 문자가 맨 끝에 붙어있음. 정렬하면 NULL 문자가 맨앞으로 온다.
	
	sort(begin(str), end(str));
	
	cout << str+1 << endl; //Null 문자가 맨앞에 와서 결과가 안 나오는 것을 막기 위해 +1을 해줌.
	
	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-10-05 오후 2:55:03 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                               (5주 1일)

값을 정렬해본다. 버블 정렬.
처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다. 
STACK, DATA, HEPA(Free Store), CODE */

//-------------------------------------------------------------------------

// [문제] 문장을 오름차순으로 정렬하여 출력하라.
// (의문) 내림차순으로 정렬할 수는 없을까?

#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std;

bool xxx(char, char); // 함수 정의 (맞는지 아닌지에 대해 판단해주는 함수)
bool xxx(char a, char b)
{
	return (a > b); // 조건이 참이면 리턴시킨다.(참이다)
}
int main()
{
	char str[] = "The qiuck brown fox jumps over the lazy dog"; //NULL 문자가 맨 끝에 붙어있음. 정렬하면 NULL 문자가 맨앞으로 온다.
	

	sort(begin(str), end(str), xxx); // xxx 함수로 내림차순으로 정렬 가능
	
	cout << str+1 << endl; //Null 문자가 맨앞에 와서 결과가 안 나오는 것을 막기 위해 +1을 해줌.
	
	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-10-05 오후 3:10:23 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                               (5주 1일)

값을 정렬해본다. 버블 정렬.
처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다. 
STACK, DATA, HEPA(Free Store), CODE */

//-------------------------------------------------------------------------

// [문제] 문장을 오름차순으로 정렬하여 출력하라.
// (의문) 내림차순으로 정렬할 수는 없을까?

#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std;


int main()
{
	char str[] = "The qiuck brown fox jumps over the lazy dog"; 
	//NULL 문자가 맨 끝에 붙어있음. 정렬하면 NULL 문자가 맨앞으로 온다.
	

	sort(begin(str), end(str), [](char a, char b) {
		return a > b; 
		} ); 
	// 부를 수 없는 함수 []를 정의함. 부를일이 없기에 함수이름이 없음. a가 b보다 작을때 참이다.(내림차순)
	// 함수의 기능만 쓰고 싶고 호출은 안하기 때문에 이름없는 함수가 존재한다.
	
	cout << str+1 << endl; //Null 문자가 맨앞에 와서 결과가 안 나오는 것을 막기 위해 +1을 해줌.
	
	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-10-05 오후 3:16:14 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                               (5주 1일)

값을 정렬해본다. 버블 정렬.
처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다. 
STACK, DATA, HEPA(Free Store), CODE */

//-------------------------------------------------------------------------


#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

// [문제] 소수점 10만개를 저장하고 오름차순으로 정렬 후 출력하라.

default_random_engine dre;
uniform_int_distribution<> uid{ 'a', 'z' };

int main()
{
	
	char alpha[10'0000];

	for (char& c : alpha)
		c = uid(dre);
	
	// sort(begin(alpha), end(alpha));

	cout << alpha << endl;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-10-05 오후 3:18:11 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                               (5주 1일)

값을 정렬해본다. 버블 정렬.
처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다. 
STACK, DATA, HEPA(Free Store), CODE */

//-------------------------------------------------------------------------


#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

// [문제] 소문자 10만개를 저장하고 오름차순으로 정렬 후 출력하라.

default_random_engine dre;
uniform_int_distribution<> uid{ 'a', 'z' };

int main()
{
	
	char alpha[10'0000];

	for (char& c : alpha) // alpha를 조작하기 위해 레퍼런스(&)를 사용해야 함.
		c = uid(dre);
	
	sort(begin(alpha), end(alpha)); //오름차순 식.
	// alpha가 초기화되어 있지 않았기 때문에 NULL이 없어서 오류가 뜨지 않음.

	cout << alpha << endl;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-10-07 오후 12:09:44 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                               (5주 1일)

값을 정렬해본다. 버블 정렬.
처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다. 
STACK, DATA, HEPA(Free Store), CODE */

//-------------------------------------------------------------------------


#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

// [문제] 소문자 200만개를 저장하고 오름차순으로 정렬 후 출력하라.

default_random_engine dre;
uniform_int_distribution<> uid{ 'a', 'z' };

int main()
{
	
	char alpha[100'0000];

	cout << (void*)(char*)alpha << endl;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-10-07 오후 12:11:44 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                               (5주 1일)

값을 정렬해본다. 버블 정렬.
처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다. 
STACK, DATA, HEPA(Free Store), CODE */

//-------------------------------------------------------------------------


#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

// [문제] 소문자 200만개를 저장하고 오름차순으로 정렬 후 출력하라.

default_random_engine dre;
uniform_int_distribution<> uid{ 'a', 'z' };

int main()
{
	
	char alpha[100'0000];

	cout << (void*)(char*)alpha << endl; 

	// 200만개는 안 돌아가는 게 정상인데 alpha를 사용하는 곳이 없으면 프로그램이 돌아가게 됨.
	// cout으로 void형, char형으로 바꿔주면서 돌아갈 수 있게 만들어줌

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-10-07 오후 12:14:05 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                               (5주 1일)

값을 정렬해본다. 버블 정렬.
처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다. 
STACK, DATA, HEPA(Free Store), CODE */

//-------------------------------------------------------------------------


#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

// [문제] 소문자 200만개를 저장하고 오름차순으로 정렬 후 출력하라.

default_random_engine dre;
uniform_int_distribution<> uid{ 'a', 'z' };

int main()
{
	
	char alpha[1'000'000];			// alpha는 지역변수이고
									// 지역변수는 STACK에 생성된다.
									// 최대 1MB까지 사용할 수 있다.

	cout << (void*)(char*)alpha << endl; 

	// 200만개는 안 돌아가는 게 정상인데 alpha를 사용하는 곳이 없으면 프로그램이 돌아가게 됨.
	// cout으로 void형, char형으로 바꿔주면서 돌아갈 수 있게 만들어줌

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-10-07 오후 12:53:53 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                               (5주 1일)

값을 정렬해본다. 버블 정렬.
처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다. 
STACK, DATA, HEPA(Free Store), CODE */

//-------------------------------------------------------------------------


#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

// [문제] 소문자 천만개를 저장하고 내림차순으로 정렬한 후
// 제일 첫글자와 제일 마지막 글자를 화면에 출력하라.

default_random_engine dre{ random_device()() };	// 크기가 너무 크기때문에 지역변수로 안 씀
												// dre 값 초기화하기 위해 랜덤 디바이스 씀
uniform_int_distribution<> uid{ 'a', 'z' }; 

char c[10'000'000];

int main()
{
	for (char& c : c)
		c = uid(dre);

	sort(begin(c), end(c), [](char a, char b) {
		return a < b;
		});

	cout << "전체 글자의 개수 : " << sizeof(c) << endl;
	cout << "제일 첫글자 - " << c[0] << endl;
	cout << "제일 마지막 글자 - " << c[sizeof(c) - 1] << endl;
	
	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-10-07 오후 12:55:54 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                               (5주 1일)

값을 정렬해본다. 버블 정렬.
처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다. 
STACK, DATA, HEPA(Free Store), CODE */

//-------------------------------------------------------------------------


#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

// [문제] 소문자 천만개를 저장하고 내림차순으로 정렬한 후
// 제일 첫글자와 제일 마지막 글자를 화면에 출력하라.

default_random_engine dre{ random_device()() };	// 크기가 너무 크기때문에 지역변수로 안 씀
												// dre 값 초기화하기 위해 랜덤 디바이스 씀
uniform_int_distribution<> uid{ 'a', 'z' }; 

char c[100'000'000];

int main()
{
	cout << "값을 쓰는 중" << endl;
	for (char& c : c)
		c = uid(dre);

	cout << "값을 정렬하는 중" << endl;
	sort(begin(c), end(c), [](char a, char b) {
		return a < b;
		});

	cout << "전체 글자의 개수 : " << sizeof(c) << endl;
	cout << "제일 첫글자 - " << c[0] << endl;
	cout << "제일 마지막 글자 - " << c[sizeof(c) - 1] << endl;
	
	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-10-07 오후 12:56:47 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                               (5주 1일)

값을 정렬해본다. 버블 정렬.
처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다. 
STACK, DATA, HEPA(Free Store), CODE */

//-------------------------------------------------------------------------


#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

// [문제] 소문자 천만개를 저장하고 내림차순으로 정렬한 후
// 제일 첫글자와 제일 마지막 글자를 화면에 출력하라.

default_random_engine dre{ random_device()() };	// 크기가 너무 크기때문에 지역변수로 안 씀
												// dre 값 초기화하기 위해 랜덤 디바이스 씀
uniform_int_distribution<> uid{ 'a', 'z' }; 

char c[1'000'000'000];

int main()
{
	cout << "값을 쓰는 중" << endl;
	for (char& c : c)
		c = uid(dre);

	cout << "값을 정렬하는 중" << endl;
	sort(begin(c), end(c), [](char a, char b) {
		return a < b;
		});

	cout << "전체 글자의 개수 : " << sizeof(c) << endl;
	cout << "제일 첫글자 - " << c[0] << endl;
	cout << "제일 마지막 글자 - " << c[sizeof(c) - 1] << endl;
	
	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-10-07 오후 12:58:56 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                               (5주 1일)

값을 정렬해본다. 버블 정렬.
처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다. 
STACK, DATA, HEPA(Free Store), CODE */

//-------------------------------------------------------------------------


#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

// [문제] 소문자 천만개를 저장하고 내림차순으로 정렬한 후
// 제일 첫글자와 제일 마지막 글자를 화면에 출력하라.

default_random_engine dre{ random_device()() };	// 크기가 너무 크기때문에 지역변수로 안 씀
												// dre 값 초기화하기 위해 랜덤 디바이스 씀
uniform_int_distribution<> uid{ 'a', 'z' }; 

char c[1'000'000'000]; // 1G 바이트

int main()
{
	cout << "값을 쓰는 중" << endl;
	for (char& c : c)
		c = uid(dre);

	cout << "값을 정렬하는 중" << endl;
	sort(begin(c), end(c), [](char a, char b) {
		return a < b;
		});

	cout << "전체 글자의 개수 : " << sizeof(c) << endl;
	cout << "제일 첫글자 - " << c[0] << endl;
	cout << "제일 마지막 글자 - " << c[sizeof(c) - 1] << endl;
	
	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-10-07 오후 1:00:33 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                               (5주 1일)

값을 정렬해본다. 버블 정렬.
처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다. 
STACK, DATA, HEPA(Free Store), CODE */

//-------------------------------------------------------------------------


#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

// [문제] 소문자 천만개를 저장하고 내림차순으로 정렬한 후
// 제일 첫글자와 제일 마지막 글자를 화면에 출력하라.

default_random_engine dre{ random_device()() };	// 크기가 너무 크기때문에 지역변수로 안 씀
												// dre 값 초기화하기 위해 랜덤 디바이스 씀
uniform_int_distribution<> uid{ 'a', 'z' }; 

char c[1'500'000'000]; // 1G 바이트

int main()
{
	cout << "값을 쓰는 중" << endl;
	for (char& c : c)
		c = uid(dre);

	cout << "값을 정렬하는 중" << endl;
	sort(begin(c), end(c), [](char a, char b) {
		return a < b;
		});

	cout << "전체 글자의 개수 : " << sizeof(c) << endl;
	cout << "제일 첫글자 - " << c[0] << endl;
	cout << "제일 마지막 글자 - " << c[sizeof(c) - 1] << endl;
	
	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-10-07 오후 1:19:37 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                               (5주 1일)

값을 정렬해본다. 버블 정렬.
처리할 자료의 수를 늘려가며 필요한 내용을 공부해 본다. 
STACK, DATA, HEPA(Free Store), CODE */

//-------------------------------------------------------------------------


#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

// [문제] 소문자 천만개를 저장하고 내림차순으로 정렬한 후
// 제일 첫글자와 제일 마지막 글자를 화면에 출력하라.

default_random_engine dre{ random_device()() };	// 크기가 너무 크기때문에 지역변수로 안 씀
												// dre 값 초기화하기 위해 랜덤 디바이스 씀
uniform_int_distribution<> uid{ 'a', 'z' }; 

char c[100'000'000]{ 'A' }; // 100M 바이트. 초기값을 깔아주면 실행파일 자체의 용량이 커짐.
// 초기값이 없으면 그만큼 메모리가 차지 안 하므로 파일상의 실행파일 용량이 크지 않음.

int main()
{
	cout << "값을 쓰는 중" << endl;
	for (char& c : c)
		c = uid(dre);

	cout << "값을 정렬하는 중" << endl;
	sort(begin(c), end(c), [](char a, char b) {
		return a < b;
		});

	cout << "전체 글자의 개수 : " << sizeof(c) << endl;
	cout << "제일 첫글자 - " << c[0] << endl;
	cout << "제일 마지막 글자 - " << c[sizeof(c) - 1] << endl;
	
	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-10-14 오전 11:34:57 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                               (6주 1일)

사용자 정의 자료형 */
//-------------------------------------------------------------------------


#include <iostream>
#include <algorithm>
#include <fstream>
#include "save.h"
using namespace std;

// [문제] 파일에 '정수 1억개.txt'가 저장되어 있다.
// 읽어서 오름차순으로 정렬한 후
// '정수 1억개 오름차순정렬.txt'로 저장하라.


int main()
{
	ifstream in("정수 1억개.txt");

	int num;
	while (in >> num)
		cout << num;
	
	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-10-14 오전 11:41:29 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                               (6주 1일)

사용자 정의 자료형 */
//-------------------------------------------------------------------------


#include <iostream>
#include <algorithm>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;

// [문제] 파일에 '정수 1억개.txt'가 저장되어 있다.
// 읽어서 오름차순으로 정렬한 후
// '정수 1억개 오름차순정렬.txt'로 저장하라.

void makedata()
{
	ofstream out("정수 1억개.txt");
	default_random_engine dre;

}
int main()
{
	ifstream in("정수 1억개.txt");

	int num;
	int cnt{ 0 };
	while (in >> num)				// 인풋파일에서 읽어오는 동안
		//cout << num << '\n';
		++cnt;

	cout << "읽은 개수 - " << cnt << '\n';
	
	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-10-14 오전 11:57:35 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                               (6주 1일)

사용자 정의 자료형 */
//-------------------------------------------------------------------------


#include <iostream>
#include <algorithm>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;

// [문제] 파일에 '정수 1억개.txt'가 저장되어 있다.
// 읽어서 오름차순으로 정렬한 후
// '정수 1억개 오름차순정렬.txt'로 저장하라.

void makedata()
{
	ofstream out("정수 1억개.txt");
	default_random_engine dre;

}

int arr[1'0000'0000];		// 400MB 필요, 너무 커서 지역변수 불가

int main()
{
	ifstream in("정수 1억개.txt");

	int num;
	int cnt{ 0 };

	cout << "읽는 중";
	while (in >> num) {			// 인풋파일에서 읽어오는 동안
		arr[cnt++] = num;
		if (!(cnt & 100'0000))
			cout << ".";
	}
	cout << endl;
	cout << "모두 " << cnt << "개의 정수를 읽었습니다." << '\n';

	cout << "정렬하는 중" << endl;
	
	sort(begin(arr), end(arr), [&cnt](int a, int b) { // cnt를 원격조종하려고 [] 안에 써줌
		if (!(++cnt % 100'0000))
			cout << ".";
		return a < b;
		});

	cout << endl;
	// 앞에서부터 100개만 출력
	for (int i = 0; i < 100; ++i)
		cout << arr[i] << endl;
	
	save("소스.cpp");
}





//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                               (6주 1일)

사용자 정의 자료형 */
//-------------------------------------------------------------------------


#include <iostream>
#include <algorithm>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;

// [문제] 파일에 '정수 1억개.txt'가 저장되어 있다.
// 읽어서 오름차순으로 정렬한 후
// '정수 1억개 오름차순정렬.txt'로 저장하라.

void makedata()
{
	ofstream out("정수 1억개.txt");
	default_random_engine dre;

}

int arr[1'0000'0000];		// 400MB 필요, 너무 커서 지역변수 불가

int main()
{
	ifstream in("정수 1억개.txt");

	int num;
	int cnt{ 0 };

	cout << "읽는 중";
	while (in >> num) {			// 인풋파일에서 읽어오는 동안
		arr[cnt++] = num;
		if (!(cnt & 100'0000))
			cout << ".";
	}
	cout << endl;
	cout << "모두 " << cnt << "개의 정수를 읽었습니다." << '\n';

	cout << "정렬하는 중" << endl;
	
	sort(begin(arr), end(arr), [&cnt](int a, int b) { // cnt를 원격조종하려고 [] 안에 써줌
		if (!(++cnt % 100'0000))
			cout << ".";
		return a < b;
		});

	cout << endl;

	// 전체를 파일에 기록 
	ofstream out{ "정수 1억개 오름차순정렬.txt"s }; // 끝에 s를 붙이는 건 파일 전체가 str이라는 뜻
	
	for (int n : arr)
		cout << n << " ";

	save("소스.cpp");
}





//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                               (6주 1일)

사용자 정의 자료형 */
//-------------------------------------------------------------------------


#include <iostream>
#include <algorithm>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;

// [문제] 파일에 '정수 1억개.txt'가 저장되어 있다.
// 읽어서 오름차순으로 정렬한 후
// '정수 1억개 오름차순정렬.txt'로 저장하라.

void makedata()
{
	ofstream out("정수 1억개.txt");
	default_random_engine dre;

}

int arr[1'0000'0000];		// 400MB 필요, 너무 커서 지역변수 불가

/*int main()
{
	ifstream in("정수 1억개.txt");

	int num;
	int cnt{ 0 };

	cout << "읽는 중";
	while (in >> num) {			// 인풋파일에서 읽어오는 동안
		arr[cnt++] = num;
		if (!(cnt & 100'0000))
			cout << ".";
	}
	cout << endl;
	cout << "모두 " << cnt << "개의 정수를 읽었습니다." << '\n';

	cout << "정렬하는 중" << endl;
	
	sort(begin(arr), end(arr), [&cnt](int a, int b) { // cnt를 원격조종하려고 [] 안에 써줌
		if (!(++cnt % 100'0000))
			cout << ".";
		return a < b;
		});

	cout << endl;

	// 전체를 파일에 기록 
	ofstream out{ "정수 1억개 오름차순정렬.txt"s }; // 끝에 s를 붙이는 건 파일 전체가 str이라는 뜻
	
	for (int n : arr)
		cout << n << " ";

	save("소스.cpp");
}*/

int main()
{
	ifstream in("정수 1억개 오름차순정렬.txt"s);

	int num;
	while (in >> num) {
		cout << num << endl;
		this_thread::sleep_for;
	}

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-10-14 오후 12:43:17 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                               (6주 1일)

사용자 정의 자료형 - 
struct - 모든 메모리를 읽고 써도 되는 경우
calss - 메모리의 access 하려면 interface를 사용해야 하는 경우 */
//-------------------------------------------------------------------------


#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Person { 			// 선언. {} 부분이 정의. {}를 써야 메모리를 어느정도 할당할지 결정이 됨.
	int age;				// 1바이트 안에 들어갈 수 있는 메모리지만 4바이트 사용 중
	string name;			// 앞으로 C++에서는 char name[40] 대신 string 사용
};

int main()
{
	Person p;				// 사용자 자료형을 쓰고 싶으면 struct 혹은 class 사용
	cout << sizeof(Person) << endl;			// 28 바이트 나옴 (int 4바이트, string 24바이트)
	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-10-14 오후 12:46:26 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                               (6주 1일)

사용자 정의 자료형 - 
struct - 모든 메모리를 읽고 써도 되는 경우
calss - 메모리의 access 하려면 interface를 사용해야 하는 경우 */
//-------------------------------------------------------------------------


#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Person { 			// 선언. {} 부분이 정의. {}를 써야 메모리를 어느정도 할당할지 결정이 됨.
	char age;				// 1바이트 안에 들어갈 수 있는 메모리. char형(1바이트) 사용.
	string name;			// 앞으로 C++에서는 char name[40] 대신 string 사용
};

int main()
{
	Person p;				// 사용자 자료형을 쓰고 싶으면 struct 혹은 class 사용
	cout << sizeof(Person) << endl; // 여전히 28바이트 사용중. (char 1바이트 + string 24바이트 = ?)
									// 속도를 위해 메모리를 사용. 3바이트의 빈공간을 padding이라고 한다. 컴퓨터는 짝수를 좋아함.
	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-10-14 오후 12:54:36 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                               (6주 1일)

사용자 정의 자료형 - 
struct - 모든 메모리를 읽고 써도 되는 경우
calss - 메모리의 access 하려면 interface를 사용해야 하는 경우 */
//-------------------------------------------------------------------------


#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct alignas(32) Person { // 선언. {} 부분이 정의. {}를 써야 메모리를 어느정도 할당할지 결정이 됨.
							// alignas(32) = 메모리를 32 바이트로 정한다는 것. 홀수는 안 됨.
	char age;				// 1바이트 안에 들어갈 수 있는 메모리. char형 사용.
	string name;			// 앞으로 C++에서는 char name[40] 대신 string 사용
};

int main()
{
	Person p;				// 사용자 자료형을 쓰고 싶으면 struct 혹은 class 사용
	cout << sizeof(Person) << endl;
	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-02 오후 7:51:02 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      10월 5일 (5주 1일)

처리해야 자료의 수가 점점 늘어난다
어떻게 하지?
어디에 읽어와야 하나?
몇개까지 처리할 수 있나? */
//-------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std;

int main()
{
	char str[]{ "C++ is a nice programming language" };
	cout << str << endl;

	sort(begin(str), end(str), [](char a, char b) {
		return a > b;
		});

	cout << "정렬 후 " << endl;
	cout << str << endl; 

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-02 오후 8:16:13 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      10월 5일 (5주 1일)

처리해야 자료의 수가 점점 늘어난다
어떻게 하지?
어디에 읽어와야 하나?
몇개까지 처리할 수 있나? */
//-------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std;

bool 내림차순(char, char);

bool 내림차순(char a, char b) 
{
	if (a > b)
		return true;
	return false;
}

int main()
{
	char str[]{ "C++ is a nice programming language" }; // [] 안을 비워두면 컴파일러가 알아서 숫자를 세서 넣어줌
	cout << str << endl;

	sort(begin(str), end(str), 내림차순);

	cout << "정렬 후 " << endl;
	cout << str << endl; 

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-02 오후 8:16:42 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      10월 5일 (5주 1일)

처리해야 자료의 수가 점점 늘어난다
어떻게 하지?
어디에 읽어와야 하나?
몇개까지 처리할 수 있나? */
//-------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std;

bool 내림차순(char, char);

bool 내림차순(char a, char b) 
{
	if (a > b)
		return true;
	return false;
}

int main()
{
	char str[]{ "12324335621356580987861" }; // [] 안을 비워두면 컴파일러가 알아서 숫자를 세서 넣어줌
	cout << str << endl;

	sort(begin(str), end(str), 내림차순);

	cout << "정렬 후 " << endl;
	cout << str << endl; 

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-02 오후 8:18:37 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      10월 5일 (5주 1일)

처리해야 자료의 수가 점점 늘어난다
어떻게 하지?
어디에 읽어와야 하나?
몇개까지 처리할 수 있나? */
//-------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std;

bool 내림차순(char, char);

bool 내림차순(char a, char b) 
{
	static int i = 0;
	cout << "내림차순을 호출한 횟수 - " << ++i << endl;
	return a > b;
}

int main()
{
	char str[]{ "12324335621356580987861" }; // [] 안을 비워두면 컴파일러가 알아서 숫자를 세서 넣어줌
	cout << str << endl;

	sort(begin(str), end(str), 내림차순);

	cout << "정렬 후 " << endl;
	cout << str << endl; 

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-02 오후 8:19:42 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      10월 5일 (5주 1일)

처리해야 자료의 수가 점점 늘어난다
어떻게 하지?
어디에 읽어와야 하나?
몇개까지 처리할 수 있나? */
//-------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std;

bool 내림차순(char, char);

bool 내림차순(char a, char b) 
{
	static int i = 0;
	cout << a << ", " << b <<  "내림차순을 호출한 횟수 - " << ++i << endl;
	return a > b;
}

int main()
{
	char str[]{ "0123456789" }; // [] 안을 비워두면 컴파일러가 알아서 숫자를 세서 넣어줌
	cout << str << endl;

	sort(begin(str), end(str), 내림차순);

	cout << "정렬 후 " << endl;
	cout << str << endl; 

	save("소스.cpp");
}





//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-02 오후 8:24:35 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      10월 5일 (5주 1일)

처리해야 자료의 수가 점점 늘어난다
어떻게 하지?
어디에 읽어와야 하나?
몇개까지 처리할 수 있나? */
//-------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std;

// 이름없는 함수 람다(lamda)
bool 내림차순(char, char);

bool 내림차순(char a, char b) 
{
	static int i = 0;
	cout << a << ", " << b <<  "내림차순을 호출한 횟수 - " << ++i << endl;
	return a > b;
}

int main()
{
	cout << boolalpha << 내림차순('1', 'a') << endl; // 잘못된 것. a가 왼쪽으로 가야 된다고 대답해줌.(false)

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-02 오후 8:24:48 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      10월 5일 (5주 1일)

처리해야 자료의 수가 점점 늘어난다
어떻게 하지?
어디에 읽어와야 하나?
몇개까지 처리할 수 있나? */
//-------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std;

// 이름없는 함수 람다(lambda)
bool 내림차순(char, char);

bool 내림차순(char a, char b) 
{
	static int i = 0;
	cout << a << ", " << b <<  "내림차순을 호출한 횟수 - " << ++i << endl;
	return a > b;
}

int main()
{
	cout << boolalpha << 내림차순('a', 'b') << endl; // 잘못된 것. a가 왼쪽으로 가야 된다고 대답해줌.(false)

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-02 오후 8:25:13 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      10월 5일 (5주 1일)

처리해야 자료의 수가 점점 늘어난다
어떻게 하지?
어디에 읽어와야 하나?
몇개까지 처리할 수 있나? */
//-------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std;

// 이름없는 함수 람다(lambda)
bool 내림차순(char, char);

bool 내림차순(char a, char b) 
{
	static int i = 0;
	cout << a << ", " << b <<  "내림차순을 호출한 횟수 - " << ++i << endl;
	return a > b;
}

int main()
{
	cout << boolalpha << 내림차순('b', 'a') << endl; // 맞음. (true)

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-02 오후 8:31:29 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      10월 5일 (5주 1일)

처리해야 자료의 수가 점점 늘어난다
어떻게 하지?
어디에 읽어와야 하나?
몇개까지 처리할 수 있나? */
//-------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std;

// 이름없는 함수 람다(lambda)
bool 내림차순(char, char);

bool 내림차순(char a, char b) 
{
	static int i = 0;
	cout << a << ", " << b <<  "내림차순을 호출한 횟수 - " << ++i << endl;
	return a > b;
}

int main()
{
	char str[]{ "12345" };
	
	sort(begin(str), end(str), [](char a, char b) { //여기서 []를 lambda라고 부름.
		return a > b;
	} );

	cout << str << endl;

	save("소스.cpp");

}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-02 오후 8:32:18 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      10월 5일 (5주 1일)

처리해야 자료의 수가 점점 늘어난다
어떻게 하지?
어디에 읽어와야 하나?
몇개까지 처리할 수 있나? */
//-------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std;

// 이름없는 함수 람다(lambda)

int main()
{
	char str[]{ "12345" };
	
	sort(begin(str), end(str), [](char a, char b) { //여기서 []를 lambda라고 부름.
		static int i{};
		cout << i++ << endl;
		return a > b;
	} );

	cout << str << endl;

	save("소스.cpp");

}





//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-02 오후 8:38:20 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      10월 5일 (5주 1일)

처리해야 자료의 수가 점점 늘어난다
어떻게 하지?
어디에 읽어와야 하나?
몇개까지 처리할 수 있나? */
//-------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std;

// 이름없는 함수 람다(lambda)

int main()
{
	char str[]{ "12345" };
	
	sort(begin(str), end(str), [](char a, char b) { //여기서 []를 lambda라고 부름.						
		return a > b;								//lambda의 장점은 가독성이 좋다, 코드 인라인화(함수호출)을 피할 수 있다.
	});												//함수호출을 피하면 복잡한 작업을 피할 수 있음.

	cout << str << endl;

	save("소스.cpp");

}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-02 오후 8:45:28 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      10월 7일 (5주 2일)

처리해야 자료의 수가 점점 늘어난다
어떻게 하지?
어디에 읽어와야 하나?
몇개까지 처리할 수 있나? */
//-------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std;

char c[10000000];			// DATA segment - 전역변수 c

int main()
{
	char c[100];		// STACK segment - 지역변수 c

	new char[100];		// HEAP, Free Store. (최신 인기)

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-02 오후 8:55:07 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      10월 7일 (5주 2일)

처리해야 자료의 수가 점점 늘어난다
어떻게 하지?
어디에 읽어와야 하나?
몇개까지 처리할 수 있나? */
//-------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

// [문제] 임의의 소문자 100개를 저장하라
// 내림차순으로 정렬하라
// 정렬한 문자를 출력하라

default_random_engine dre;
uniform_int_distribution<> uid{ 'a', 'z' };

int main()
{
	char c[100];					// 100개는 지역변수로도 충분
	
	for (int i = 0; i < 100; ++i)	// 잘 안 쓰는 문법임.
		c[i] = uid(dre);

	cout << c << endl;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-02 오후 9:05:41 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      10월 7일 (5주 2일)

처리해야 자료의 수가 점점 늘어난다
어떻게 하지?
어디에 읽어와야 하나?
몇개까지 처리할 수 있나? */
//-------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

// [문제] 임의의 소문자 100개를 저장하라
// 내림차순으로 정렬하라
// 정렬한 문자를 출력하라

default_random_engine dre;
uniform_int_distribution<> uid{ 'a', 'z' };

int main()
{
	char c[100];			// 100개는 지역변수로도 충분
	
	for (char& c : c)		// 유지 보수에 쉬운 문법. &를 써야 c를 직접 바꿀 수 있음.
		c = uid(dre);

	for (char ch : c)		// char ch에 c의 값을 넣어 cout 함. 값 변경하는 거 아님.
		cout << ch;

	cout << c << endl;		// 끝에 ?꽗뚫 같은 문자가 나올 수 있는데, 그 이유는
							// 
	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-02 오후 9:08:50 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      10월 7일 (5주 2일)

처리해야 자료의 수가 점점 늘어난다
어떻게 하지?
어디에 읽어와야 하나?
몇개까지 처리할 수 있나? */
//-------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

// [문제] 임의의 소문자 100개를 저장하라
// 내림차순으로 정렬하라
// 정렬한 문자를 출력하라

default_random_engine dre;
uniform_int_distribution<> uid{ 'a', 'z' };

int main()
{
	char c[100];			// 100개는 지역변수로도 충분
	
	for (char& c : c)		// 유지 보수에 쉬운 문법. &를 써야 c를 직접 바꿀 수 있음.
		c = uid(dre);

	sort(begin(c), end(c), [](char a, char b) {
		return a > b;		// 내림차순. 화살표 주의. 
		});

	for (char ch : c)		// char ch에 c의 값을 넣어 cout 함. 값 변경하는 거 아님.
		cout << ch;
	cout << endl << endl;


	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-02 오후 9:09:52 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      10월 7일 (5주 2일)

처리해야 자료의 수가 점점 늘어난다
어떻게 하지?
어디에 읽어와야 하나?
몇개까지 처리할 수 있나? */
//-------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

// [문제] 임의의 소문자 1'0000개를 저장하라
// 내림차순으로 정렬하라
// 정렬한 문자를 출력하라

default_random_engine dre;
uniform_int_distribution<> uid{ 'a', 'z' };

int main()
{
	char c[1'0000];			// 10000개로 바꾸어도 여기만 바꾸면 유지보수 가능
	
	for (char& c : c)		// 유지 보수에 쉬운 문법. &를 써야 c를 직접 바꿀 수 있음.
		c = uid(dre);

	sort(begin(c), end(c), [](char a, char b) {
		return a > b;		// 내림차순. 화살표 주의. 
		});

	for (char ch : c)		// char ch에 c의 값을 넣어 cout 함. 값 변경하는 거 아님.
		cout << ch;
	cout << endl << endl;


	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-02 오후 9:12:56 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      10월 7일 (5주 2일)

처리해야 자료의 수가 점점 늘어난다
어떻게 하지?
어디에 읽어와야 하나?
몇개까지 처리할 수 있나? */
//-------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

// [문제] 임의의 소문자 1'0000개를 저장하라
// 내림차순으로 정렬하라
// 정렬한 문자를 출력하라
// 도대체 지역변수는 몇개까지 저장할 수 있나?

default_random_engine dre;
uniform_int_distribution<> uid{ 'a', 'z' };

int main()
{
	char c[10'0000];			// 10000개로 바꾸어도 여기만 바꾸면 유지보수 가능
	
	for (char& c : c)		// 유지 보수에 쉬운 문법. &를 써야 c를 직접 바꿀 수 있음.
		c = uid(dre);

	sort(begin(c), end(c), [](char a, char b) {
		return a > b;		// 내림차순. 화살표 주의. 
		});

	// 제일 첫 글자
	cout << c[0] << endl;
	// 제일 마지막 글자
	cout << c[sizeof(c) - 1] << endl;


	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-02 오후 9:15:19 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      10월 7일 (5주 2일)

처리해야 자료의 수가 점점 늘어난다
어떻게 하지?
어디에 읽어와야 하나?
몇개까지 처리할 수 있나? */
//-------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

// [문제] 임의의 소문자 1'0000개를 저장하라
// 내림차순으로 정렬하라
// 정렬한 문자를 출력하라
// 도대체 지역변수는 몇개까지 저장할 수 있나?

default_random_engine dre;
uniform_int_distribution<> uid{ 'a', 'z' };

int main()
{
	char c[100'000];		// 100 KB
	
	for (char& c : c)		// 유지 보수에 쉬운 문법. &를 써야 c를 직접 바꿀 수 있음.
		c = uid(dre);

	sort(begin(c), end(c), [](char a, char b) {
		return a > b;		// 내림차순. 화살표 주의. 
		});

	// 제일 첫 글자
	cout << c[0] << endl;
	// 제일 마지막 글자
	cout << c[sizeof(c) - 1] << endl;


	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-02 오후 9:15:56 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      10월 7일 (5주 2일)

처리해야 자료의 수가 점점 늘어난다
어떻게 하지?
어디에 읽어와야 하나?
몇개까지 처리할 수 있나? */
//-------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

// [문제] 임의의 소문자 1'0000개를 저장하라
// 내림차순으로 정렬하라
// 정렬한 문자를 출력하라
// 도대체 지역변수는 몇개까지 저장할 수 있나?

default_random_engine dre;
uniform_int_distribution<> uid{ 'a', 'z' };

int main()
{
	char c[1'000'000];		// 1 MB
	
	for (char& c : c)		// 유지 보수에 쉬운 문법. &를 써야 c를 직접 바꿀 수 있음.
		c = uid(dre);

	sort(begin(c), end(c), [](char a, char b) {
		return a > b;		// 내림차순. 화살표 주의. 
		});

	// 제일 첫 글자
	cout << c[0] << endl;
	// 제일 마지막 글자
	cout << c[sizeof(c) - 1] << endl;


	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-02 오후 9:17:36 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      10월 7일 (5주 2일)

처리해야 자료의 수가 점점 늘어난다
어떻게 하지?
어디에 읽어와야 하나?
몇개까지 처리할 수 있나? */
//-------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"
using namespace std;

// [문제] 임의의 소문자 1'0000개를 저장하라
// 내림차순으로 정렬하라
// 정렬한 문자를 출력하라
// 도대체 지역변수는 몇개까지 저장할 수 있나?

default_random_engine dre;
uniform_int_distribution<> uid{ 'a', 'z' };

int main()
{
	char c[1'000'000];		// 1 MB, 지역변수는 1MB 이상 못 쓴다.
							// c는 지역변수이고 STACK에 생성된다
							// STACK의 크기는 1MB가 최대값이다 라는 결론.
	
	for (char& c : c)		// 유지 보수에 쉬운 문법. &를 써야 c를 직접 바꿀 수 있음.
		c = uid(dre);

	sort(begin(c), end(c), [](char a, char b) {
		return a > b;		// 내림차순. 화살표 주의. 
		});

	// 제일 첫 글자
	cout << c[0] << endl;
	// 제일 마지막 글자
	cout << c[sizeof(c) - 1] << endl;


	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-02 오후 9:36:07 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      10월 12일 (6주 2일)

 메모리가 다 같은 곳에 사는 것은 아니다
 1. STACK - 지역변수, 1MB
 2. DATA - 전역변수
 3. Free Store (new 뭐시기) */
//-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// 정수 100개를 저장할 수 있는 공간

int c[100];			// DATA

int main()
{
	int c[100];		// STACK, 1MB
	
	new int[100];	// Free Store

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-02 오후 9:42:02 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      10월 12일 (6주 2일)

 메모리가 다 같은 곳에 사는 것은 아니다
 1. STACK - 지역변수, 1MB
 2. DATA - 전역변수
 3. Free Store (new 뭐시기) */
//-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// 정수 100개를 저장할 수 있는 공간

int a[100'000'000 ];		// DATA - 이 때 어떤 일이 일어나나?
							// 400메가 바이트의 메모리를 사용하고 있다. (int라서)
// 메모리는 시스템이 제공하는 자원이다.
// 작업관리자에서 프로그램이 사용하는 메모리를 관찰할 수 있다.
int main()
{
	for(int i = 0 ; i < 1'0000'0000; ++i )
		a[i] = i;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-02 오후 9:44:04 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      10월 12일 (6주 2일)

 메모리가 다 같은 곳에 사는 것은 아니다
 1. STACK - 지역변수, 1MB
 2. DATA - 전역변수
 3. Free Store (new 뭐시기) */
//-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// 정수 100개를 저장할 수 있는 공간

int a[100'000'000 ];		// DATA - 이 때 어떤 일이 일어나나?
							// 400메가 바이트의 메모리를 사용하고 있다. (int라서)
// 메모리는 시스템이 제공하는 자원이다.
// 작업관리자에서 프로그램이 사용하는 메모리를 관찰할 수 있다.
int main()
{
	for(int i = 0 ; i < 1'0000'0000; ++i )
		a[i] = i;

	cout << "키를 누르면 끝납니다. " << endl;
	char ch;
	cin >> ch;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-02 오후 9:47:17 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      10월 12일 (6주 2일)

 메모리가 다 같은 곳에 사는 것은 아니다
 1. STACK - 지역변수, 1MB
 2. DATA - 전역변수
 3. Free Store (new 뭐시기) */
//-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// 정수 100개를 저장할 수 있는 공간

int a[200'000'000 ];		// DATA - 이 때 어떤 일이 일어나나?
							// 400메가 바이트의 메모리를 사용하고 있다. (int라서)
// 메모리는 시스템이 제공하는 자원이다.
// 작업관리자에서 프로그램이 사용하는 메모리를 관찰할 수 있다.
int main()
{
	for (int& n : a)		// 이렇게 for 루프 코드를 짜야 유지보수 쉬움
		n = 333;			// n 값에 아무거나 넣은 거

	cout << "키를 누르면 끝납니다. " << endl;
	char ch;
	cin >> ch;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-02 오후 9:55:14 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      10월 12일 (6주 2일)

 메모리가 다 같은 곳에 사는 것은 아니다
 1. STACK - 지역변수, 1MB
 2. DATA - 전역변수
 3. Free Store (new 뭐시기) */
//-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

int a[250'000'000]{ 1, 2, 3 }; // 1GB

// DATA - 이 때 어떤 일이 일어나나?
// 1. 시스템 메모리가 이 크기만큼 사용된다.
// 관찰 - exe 파일의 크기는 얼마인가? - 28KB
// 2. 전역메모리를 초기화하면 메모리의 값이 그대로 파일에 저장된다. 1GB를 채웠을 때 하드디스크의 exe 파일의 크기도 커짐.


int main()
{
	for (int& n : a)		// 이렇게 for 루프 코드를 짜야 유지보수 쉬움
		n = 333;			// n 값에 아무거나 넣은 거

	cout << "키를 누르면 끝납니다. " << endl;
	char ch;
	cin >> ch;

	save("소스.cpp");
}




//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      10월 12일 (6주 2일)

 메모리가 다 같은 곳에 사는 것은 아니다
 1. STACK - 지역변수, 1MB

 2. DATA - 전역변수, 한 프로그램은 2GB까지 사용할 수 있다. (OS가 제한하는 것)
	전역데이터를 초기화하면 하드디스크에 기록된다. exe 파일의 크기.

 3. Free Store - 동적메모리(Dynamic Memory) 
	Dynamic -> 프로그램이 실행될 때(프로그램이 메모리에 올라온 상태)를 말함
	*/
//-------------------------------------------------------------------------
#include <iostream>
#include <thread>
#include "save.h"
using namespace std;

// [실습] 시스템의 메모리를 동적으로 할당해 본다.
// 일정 시간마다 시스템에게 일정 크기의 메모리를 요청한다.

const int SIZE = 10'000; // 10MB

int main()
{
	int i = 0;
	while (true) {
		new char[SIZE] { 3 };
	
		this_thread::sleep_for(50ms);	// 0.05초마다 메모리 요청
		cout << i++ << " 메모리 요청 - " << SIZE << endl;
	}

	save("소스.cpp");
}




//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      10월 12일 (6주 2일)

 메모리가 다 같은 곳에 사는 것은 아니다
 1. STACK - 지역변수, 1MB

 2. DATA - 전역변수, 한 프로그램은 2GB까지 사용할 수 있다. (OS가 제한하는 것)
	전역데이터를 초기화하면 하드디스크에 기록된다. exe 파일의 크기.

 3. Free Store - 동적메모리(Dynamic Memory) 
	Dynamic -> 프로그램이 실행될 때(프로그램이 메모리에 올라온 상태)를 말함
	*/
//-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// [실습] 시스템의 메모리를 동적으로 할당해 본다.
// 1. 시스템에게 일정 크기의 메모리를 요청한다.
// 2. 메모리를 사용한다.
// 3. 사용했으면 반환한다.

int n;

int main()
{
	while (true) {
		cout << "필요한 정수 갯수를 알려주세요 ";
		int num;
		cin >> num;
		int* p = new int[num];					// 1단계 : num * 4 바이트
		cout << "메모리에 값을 기록" << endl;	// 2단계 : 사용
		for (int i = 0; i < num; ++i)
			p[i] = i;

		cout << "키를 누르면 메모리를 반환합니다";
		char ch;
		cin >> ch;

		delete[] p;								// 3단계 : 반환
	}

	save("소스.cpp");
}




//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      10월 12일 (6주 2일)

 메모리가 다 같은 곳에 사는 것은 아니다
 1. STACK - 지역변수, 1MB

 2. DATA - 전역변수, 한 프로그램은 2GB까지 사용할 수 있다. (OS가 제한하는 것)
	전역데이터를 초기화하면 하드디스크에 기록된다. exe 파일의 크기.

 3. Free Store - 동적메모리(Dynamic Memory) 
	Dynamic -> 프로그램이 실행될 때(프로그램이 메모리에 올라온 상태)를 말함
	*/
//-------------------------------------------------------------------------
#include <iostream>
#include <thread>
#include "save.h"
using namespace std;

// [시연] 시스템의 메모리를 안 준다고 할 때까지 동적으로 할당해 본다.

int n;

int main()
{
	cout << "메모리 계속 할당 중 ";
	while (true) {
		int* p = new int[2500'0000 ];	
		for (int i = 0; i < 2500'0000; ++i)
			p[i] = i;

		this_thread::sleep_for(1s);	// 1초마다 2500'000 만큼 메모리 채움
		cout << ".";
	}

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-02 오후 10:30:20 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      10월 12일 (6주 2일)

 메모리가 다 같은 곳에 사는 것은 아니다
 1. STACK - 지역변수, 1MB

 2. DATA - 전역변수, 한 프로그램은 2GB까지 사용할 수 있다. (OS가 제한하는 것)
	전역데이터를 초기화하면 하드디스크에 기록된다. exe 파일의 크기.

 3. Free Store - 동적메모리(Dynamic Memory) 
	Dynamic -> 프로그램이 실행될 때(프로그램이 메모리에 올라온 상태)를 말함
	*/
//-------------------------------------------------------------------------
#include <iostream>
#include <thread>
#include "save.h"
using namespace std;

// [시연] 시스템의 메모리를 안 준다고 할 때까지 동적으로 할당해 본다.

int n;

int main()
{
	cout << "메모리 계속 할당 중 ";
	while (true) {
		int* p;
		try {						 	 // 문장이 실패하는지 검사하는 것
			p = new int[2500'0000]; // 실패한다면 예외를 집어던짐
		}
		catch (exception& e) {			// 예외는 exception. 집어던진 예외를 캐치함.
			cout << e.what() << endl;	// 캐치하면 적절한 처리를 하도록 설계. (적절한 처리 = 정상적인 종료 = 코드 0개로 종료되었습니다)
			break;
		}

		for (int i = 0; i < 2500'0000; ++i)
			p[i] = i;

		this_thread::sleep_for(1s);	// 1초마다 2500'000 만큼 메모리 채움
		cout << ".";
	}

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-02 오후 10:41:25 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      10월 12일 (6주 2일)

 메모리가 다 같은 곳에 사는 것은 아니다
 1. STACK - 지역변수, 1MB

 2. DATA - 전역변수, 한 프로그램은 2GB까지 사용할 수 있다. (OS가 제한하는 것)
	전역데이터를 초기화하면 하드디스크에 기록된다. exe 파일의 크기.

 3. Free Store - 동적메모리(Dynamic Memory) 
	Dynamic -> 프로그램이 실행될 때(프로그램이 메모리에 올라온 상태)를 말함
	*/
//-------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;

// [문제] 정수 1억개가 저장된 파일 "정수 1억개.txt"이 있다.
// 정수 1억개를 메모리에 읽어와라
// 메모리에 있는 정수 1억개를 오름차순으로 정렬하라.
// 정렬된 정수를 "정수 1억개 오름차순.txt"로 저장하라.

int main()
{	
	// 정수 1억개를 파일에 저장한다
	ofstream out{ "정수 1억개.txt" };

	mt19937 eng; // = default_random_engine eng;
	uniform_int_distribution<> uid;

	for (int i = 0; i < 100; ++i)
		cout << uid(eng) << " ";


	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-02 오후 10:42:23 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      10월 12일 (6주 2일)

 메모리가 다 같은 곳에 사는 것은 아니다
 1. STACK - 지역변수, 1MB

 2. DATA - 전역변수, 한 프로그램은 2GB까지 사용할 수 있다. (OS가 제한하는 것)
	전역데이터를 초기화하면 하드디스크에 기록된다. exe 파일의 크기.

 3. Free Store - 동적메모리(Dynamic Memory) 
	Dynamic -> 프로그램이 실행될 때(프로그램이 메모리에 올라온 상태)를 말함
	*/
//-------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;

// [문제] 정수 1억개가 저장된 파일 "정수 1억개.txt"이 있다.
// 정수 1억개를 메모리에 읽어와라
// 메모리에 있는 정수 1억개를 오름차순으로 정렬하라.
// 정렬된 정수를 "정수 1억개 오름차순.txt"로 저장하라.

int main()
{	
	// 정수 1억개를 파일에 저장한다
	ofstream out{ "정수 1억개.txt" };

	mt19937 eng; // = default_random_engine eng;
	uniform_int_distribution<> uid;

	for (int i = 0; i < 100; ++i)
		out << uid(eng) << " ";		// 정수 1억개.txt에 저장하는 방법


	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-02 오후 10:44:45 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      10월 12일 (6주 2일)

 메모리가 다 같은 곳에 사는 것은 아니다
 1. STACK - 지역변수, 1MB

 2. DATA - 전역변수, 한 프로그램은 2GB까지 사용할 수 있다. (OS가 제한하는 것)
	전역데이터를 초기화하면 하드디스크에 기록된다. exe 파일의 크기.

 3. Free Store - 동적메모리(Dynamic Memory) 
	Dynamic -> 프로그램이 실행될 때(프로그램이 메모리에 올라온 상태)를 말함
	*/
//-------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;

// [문제] 정수 1억개가 저장된 파일 "정수 1억개.txt"이 있다.
// 정수 1억개를 메모리에 읽어와라
// 메모리에 있는 정수 1억개를 오름차순으로 정렬하라.
// 정렬된 정수를 "정수 1억개 오름차순.txt"로 저장하라.

int main()
{	
	ifstream in{ "정수 1억개.txt" };

	int num;
	in >> num;	// 데이터 한 개만 저장됨

	cout << num;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-02 오후 10:45:43 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      10월 12일 (6주 2일)

 메모리가 다 같은 곳에 사는 것은 아니다
 1. STACK - 지역변수, 1MB

 2. DATA - 전역변수, 한 프로그램은 2GB까지 사용할 수 있다. (OS가 제한하는 것)
	전역데이터를 초기화하면 하드디스크에 기록된다. exe 파일의 크기.

 3. Free Store - 동적메모리(Dynamic Memory) 
	Dynamic -> 프로그램이 실행될 때(프로그램이 메모리에 올라온 상태)를 말함
	*/
//-------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;

// [문제] 정수 1억개가 저장된 파일 "정수 1억개.txt"이 있다.
// 정수 1억개를 메모리에 읽어와라
// 메모리에 있는 정수 1억개를 오름차순으로 정렬하라.
// 정렬된 정수를 "정수 1억개 오름차순.txt"로 저장하라.

int main()
{	
	ifstream in{ "정수 1억개.txt" };

	int num;
	
	while (in >> num)	// in 파일에서 읽어올 데이터가 있는 동안(파일 전체 데이터 가져옴)
		cout << num << endl;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-02 오후 10:53:37 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      10월 12일 (6주 2일)

 메모리가 다 같은 곳에 사는 것은 아니다
 1. STACK - 지역변수, 1MB

 2. DATA - 전역변수, 한 프로그램은 2GB까지 사용할 수 있다. (OS가 제한하는 것)
	전역데이터를 초기화하면 하드디스크에 기록된다. exe 파일의 크기.

 3. Free Store - 동적메모리(Dynamic Memory) 
	Dynamic -> 프로그램이 실행될 때(프로그램이 메모리에 올라온 상태)를 말함
	*/
//-------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;

// [문제] 정수 1억개가 저장된 파일 "정수 1억개.txt"이 있다.
// 정수 1억개를 메모리에 읽어와라
// 메모리에 있는 정수 1억개를 오름차순으로 정렬하라.
// 정렬된 정수를 "정수 1억개 오름차순.txt"로 저장하라.

int main()
{	
	ofstream out{ "정수 1억개.txt" };

	mt19937 eng; // = default_random_engine eng;
	uniform_int_distribution<> uid;
	
	cout << "기록 중";
	for (int i = 0; i < 100'000'000; ++i) {	// 1억개로 바꾸어서 저장
		out << uid(eng) << " ";
		if (!(i % 100'0000))
			cout << ".";
	}
		
	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-06 오후 6:54:48 - (금요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      10월 19일 (7주 1일)

 시험2 예정 - 11월 9일 (월요일 10주 1일)
	*/
//-------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

// [문제] 정수 1억개가 저장된 파일 "정수 1억개.txt"이 있다.
// 정수 1억개를 메모리에 읽어와라
// 메모리에 있는 정수 1억개를 오름차순으로 정렬하라.
// 정렬된 정수를 "정수 1억개 오름차순.txt"로 저장하라.

int main()
{
	ifstream in{ "정수 1억개.txt" };	// 메모리를 ifstream 만큼 줘. 파일 나타낼 때는 "F:root\정수 1억개.txt" 아니면 컨트롤+오 해서 해당 경로로 불러와야됨

	if (!in) {
		cout << "파일을 열 수 없습니다" << endl;
	}	// 파일이 잘 열렸는지 검사하는 방법. 파일 이름이 틀렸을 경우 오류날 수 있기 때문.

	int num;
	int cnt{};
	cout << "정수를 읽는 중";
	while (in >> num) {	// 공백마다 끊기므로 공백마다 하나씩 카운트 됨
		++cnt;
		if (!(cnt % 100'0000))	// 100만으로 나누었을 때 떨어지는 숫자가 0이면 . 찍기
			cout << ".";
	}
	cout << endl;

	cout << "모두 " << cnt << "개의 정수를 읽었습니다. " << endl;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-06 오후 7:16:11 - (금요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      10월 19일 (7주 1일)

 시험2 예정 - 11월 9일 (월요일 10주 1일)
	*/
//-------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <algorithm>
#include <iomanip>		//setw(20)을 쓰기 위해
#include "save.h"
using namespace std;

// [문제] 정수 1억개가 저장된 파일 "정수 1억개.txt"이 있다.
// 정수 1억개를 메모리에 읽어와라
// 메모리에 있는 정수 1억개를 오름차순으로 정렬하라.
// 정렬된 정수를 "정수 1억개 오름차순.txt"로 저장하라.

int arr[1'0000'0000];

int main()
{
	ifstream in{ "정수 1억개.txt" };	// 메모리를 ifstream 만큼 줘. 파일 나타낼 때는 "F:root\정수 1억개.txt" 아니면 컨트롤+오 해서 해당 경로로 불러와야됨

	if (!in) {
		cout << "파일을 열 수 없습니다" << endl;
	}	// 파일이 잘 열렸는지 검사하는 방법. 파일 이름이 틀렸을 경우 오류날 수 있기 때문.

	int num;
	int cnt{};
	cout << "정수를 읽는 중";
	while (in >> num) {			// 공백마다 끊기므로 공백마다 하나씩 카운트 됨
		arr[cnt++] = num;		// num의 값을 arr에 옮기는 작업
		if (!(cnt % 100'0000))	// 100만으로 나누었을 때 떨어지는 숫자가 0이면 . 찍기
			cout << ".";
	}
	cout << endl;

	cout << "모두 " << cnt << "개의 정수를 읽었습니다. " << endl;

	// 오름차순으로 정렬한다
	cout << "정렬하는 중";
	cnt = 0;
	sort(begin(arr), end(arr), [&cnt](int a, int b) {	//람다 지역에서 cnt를 조종하려면 [&cnt]라고 써야 됨!!!!
		if (!(++cnt % 100'0000))
			cout << ".";
		return a < b;
		});

	// 앞에서 만개만 화면에 출력한다
	for (int i = 0; i < 1'0000; ++i)
		cout << setw(20) << arr[i];		// 칸 맞춰 쓰기 위해 setw를 쓰는데 원래 이런짓 안 함

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-06 오후 7:26:49 - (금요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      10월 19일 (7주 1일)

 시험2 예정 - 11월 9일 (월요일 10주 1일)
	*/
//-------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <algorithm>
#include <iomanip>		//setw(20)을 쓰기 위해
#include "save.h"
using namespace std;

// [문제] 정수 1억개가 저장된 파일 "정수 1억개.txt"이 있다.
// 정수 1억개를 메모리에 읽어와라
// 메모리에 있는 정수 1억개를 오름차순으로 정렬하라.
// 정렬된 정수를 "정수 1억개 오름차순.txt"로 저장하라.



int main()
{
	int* arr = new int[1'0000'0000];		// Free Store. 1억개를 담을 공간의 시작번지 arr.

	ifstream in{ "정수 1억개.txt" };	// 메모리를 ifstream 만큼 줘. 파일 나타낼 때는 "F:root\정수 1억개.txt" 아니면 컨트롤+오 해서 해당 경로로 불러와야됨

	if (!in) {
		cout << "파일을 열 수 없습니다" << endl;
	}	// 파일이 잘 열렸는지 검사하는 방법. 파일 이름이 틀렸을 경우 오류날 수 있기 때문.

	int num;
	int cnt{};
	cout << "정수를 읽는 중";
	while (in >> num) {			// 공백마다 끊기므로 공백마다 하나씩 카운트 됨
		//arr[cnt++] = num;		// new int에선 못 씀
		*(arr + cnt++) = num;	// arr + cnt++의 번지수의 내용은 num이다
		if (!(cnt % 100'0000))	// 100만으로 나누었을 때 떨어지는 숫자가 0이면 . 찍기
			cout << ".";
	}
	cout << endl;

	cout << "모두 " << cnt << "개의 정수를 읽었습니다. " << endl;

	// 오름차순으로 정렬한다
	cout << "정렬하는 중";
	cnt = 0;
	sort(arr, arr+1'0000'0000, [&cnt](int a, int b) {	//람다 지역에서 cnt를 조종하려면 [&cnt]라고 써야 됨!!!!
		if (!(++cnt % 100'0000))
			cout << ".";
		return a < b;
		});

	// 뒤에서부터 만개만 화면에 출력한다
	for (int i = 0; i < 1'0000; ++i)
		cout << setw(20) << arr[1'0000'0000-1-i];		// 칸 맞춰 쓰기 위해 setw를 쓰는데 원래 이런짓 안 함

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-06 오후 7:41:15 - (금요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 19일 (7주 1일)

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	- 자료형을 어떻게 만들지?
	- 메모리의 크기는 어떻게 정해지지?
	- 메모리의 값을 어떻게 초기화하지?

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <string>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] Dog를 프로그램하고 싶다.
// Dog를 어떻게 표현하지? : 속성(물리량) - 행위(동작, 함수)

struct Dog {		// 자료형을 만드는 두개의 방법 중 하나
	int age;
	string name;	// 이름을 쓸 때는 string 사용! include string 꼭 사용해야 됨 =
};

int main()
{
	Dog dog;				// int의 4바이트로 프로그래밍하기엔 택도 없음. 그래서 사용자 정의형 가져옴
	cout << sizeof(dog);	// 28 바이트 나옴

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-06 오후 7:50:45 - (금요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 19일 (7주 1일)

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	- 자료형을 어떻게 만들지?
	- 메모리의 크기는 어떻게 정해지지?
	- 메모리의 값을 어떻게 초기화하지?

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <string>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] Dog를 프로그램하고 싶다.
// Dog를 어떻게 표현하지? : 속성(물리량) - 행위(동작, 함수)

struct Dog {		// 자료형을 만드는 두개의 방법 중 하나
	char age;		// 1바이트만 사용하기 위해 char 사용했으나 시공간 상에 이득을 위해 바이트 수를 줄이지 않음. 따라서 sizeof(dog)의 값은 28바이트.
	string name;	// 이름을 쓸 때는 string 사용! include string 꼭 사용해야 됨 =
};

int main()
{
	Dog dog;				// int의 4바이트로 프로그래밍하기엔 택도 없음. 그래서 사용자 정의형 가져옴
	cout << sizeof(dog);	// 28 바이트 나옴

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-06 오후 8:03:18 - (금요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 19일 (7주 1일)

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	- 자료형을 어떻게 만들지?
	- 메모리의 크기는 어떻게 정해지지?
	- 메모리의 값을 어떻게 초기화하지?

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <string>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] Dog를 프로그램하고 싶다.
// Dog를 어떻게 표현하지? : 속성(물리량) - 행위(동작, 함수)

struct alignas(32) Dog {		// alignas는 크기를 지정하는 명령어. 2의 배수만 가능함.
	char age;		// 1바이트만 사용하기 위해 char 사용
	string name;	// 이름을 쓸 때는 string 사용! include string 꼭 사용해야 됨 =
};

int main()
{
	Dog dog;				// int의 4바이트로 프로그래밍하기엔 택도 없음. 그래서 사용자 정의형 가져옴
	cout << sizeof(dog);	// 28 바이트 나옴

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-06 오후 8:31:51 - (금요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 21일 (7주 2일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	- 자료형을 어떻게 만들지?			- struct, class
	- 메모리의 크기는 어떻게 정해지지?	- 속도우선으로 정해짐 
	- 메모리의 값을 어떻게 초기화하지?	- 특별하게(special function)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <string>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] 풍선 100개를 생성한다.
// 풍선의 x, y 값을 [0, 100] (포함은 [], 불포함은 ()) 사이의 랜덤 값으로 설정한다.
// 위치 (50, 50)에서 반경 20의 영향을 미치는 폭탄이 터졌다.
// 폭탄의 영향권에 있는 풍선의 정보를 출력하라.
//		풍선(x, y)
// 전체 영향받은 풍선의 개수를 출력하라.

struct Balloon {	// 8 바이트
	float x;
	float y;
};

struct DrewLine {

};

int main()
{
	default_random_engine dre;
	uniform_int_distribution<> uid{ 0, 100 };
	Balloon balloons [100];	// 800 바이트, 1'000'000 바이트까지 사용 가능한 정의 공간
	
	for (int i = 0; i < 100; ++i) {		// 풍선 100개의 랜덤값을 설정함
		balloons[i].x = uid(dre);
		balloons[i].y = uid(dre);
	}

	// 풍선 100개와 폭탄의 거리를 계산한다
	for (int i = 0; i < 100; ++i) {
		float dx = balloons[i].x - 50;
		float dy = balloons[i].y - 50;
		
		if (sqrt(dx * dx + dy * dy) <= 20.0) {
			cout << "풍선(" << balloons[i].x << ", " << balloons[i].y << ")" << endl;
			int cnt;
			cnt++;
		}
	}

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-06 오후 8:33:00 - (금요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 21일 (7주 2일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	- 자료형을 어떻게 만들지?			- struct, class
	- 메모리의 크기는 어떻게 정해지지?	- 속도우선으로 정해짐 
	- 메모리의 값을 어떻게 초기화하지?	- 특별하게(special function)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <string>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] 풍선 100개를 생성한다.
// 풍선의 x, y 값을 [0, 100] (포함은 [], 불포함은 ()) 사이의 랜덤 값으로 설정한다.
// 위치 (50, 50)에서 반경 20의 영향을 미치는 폭탄이 터졌다.
// 폭탄의 영향권에 있는 풍선의 정보를 출력하라.
//		풍선(x, y)
// 전체 영향받은 풍선의 개수를 출력하라.

struct Balloon {	// 8 바이트
	float x;
	float y;
};

struct DrewLine {

};

int main()
{
	default_random_engine dre;
	uniform_int_distribution<> uid{ 0, 100 };
	Balloon balloons [100];	// 800 바이트, 1'000'000 바이트까지 사용 가능한 정의 공간
	
	for (int i = 0; i < 100; ++i) {		// 풍선 100개의 랜덤값을 설정함
		balloons[i].x = uid(dre);
		balloons[i].y = uid(dre);
	}

	// 풍선 100개와 폭탄의 거리를 계산한다
	int cnt;
	for (int i = 0; i < 100; ++i) {
		float dx = balloons[i].x - 50;
		float dy = balloons[i].y - 50;
		
		if (sqrt(dx * dx + dy * dy) <= 20.0) {
			cout << "풍선(" << balloons[i].x << ", " << balloons[i].y << ")" << endl;

			cnt++;
		}
	}

	cout << "모두 " << cnt << "개의 풍선이 터졌다" << endl;
	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-06 오후 8:35:01 - (금요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 21일 (7주 2일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	- 자료형을 어떻게 만들지?			- struct, class
	- 메모리의 크기는 어떻게 정해지지?	- 속도우선으로 정해짐 
	- 메모리의 값을 어떻게 초기화하지?	- 특별하게(special function)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <string>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] 풍선 1000개를 생성한다.
// 풍선의 x, y 값을 [0, 100] (포함은 [], 불포함은 ()) 사이의 랜덤 값으로 설정한다.
// 위치 (50, 50)에서 반경 20의 영향을 미치는 폭탄이 터졌다.
// 폭탄의 영향권에 있는 풍선의 정보를 출력하라.
//		풍선(x, y)
// 전체 영향받은 풍선의 개수를 출력하라.

struct Balloon {	// 8 바이트
	float x;
	float y;
};

struct DrewLine {

};

int main()
{
	default_random_engine dre;
	uniform_int_distribution<> uid{ 0, 100 };
	Balloon balloons [1000];	// 8000 바이트, 1'000'000 바이트까지 사용 가능한 정의 공간
	
	for (int i = 0; i < 1000; ++i) {		// 풍선 100개의 랜덤값을 설정함
		balloons[i].x = uid(dre);
		balloons[i].y = uid(dre);
	}

	// 풍선 100개와 폭탄의 거리를 계산한다
	int cnt;
	for (int i = 0; i < 1000; ++i) {
		float dx = balloons[i].x - 50;
		float dy = balloons[i].y - 50;
		
		if (sqrt(dx * dx + dy * dy) <= 20.0) {
			cout << "풍선(" << balloons[i].x << ", " << balloons[i].y << ")" << endl;
			cnt++;
		}
	}

	cout << "모두 " << cnt << "개의 풍선이 터졌다" << endl;
	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-06 오후 8:40:21 - (금요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 21일 (7주 2일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	- 자료형을 어떻게 만들지?			- struct, class
	- 메모리의 크기는 어떻게 정해지지?	- 속도우선으로 정해짐 
	- 메모리의 값을 어떻게 초기화하지?	- 특별하게(special function)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <string>
#include <random>
#include <algorithm>
#include "save.h"

using namespace std;

// [문제] 풍선 1000개를 생성한다.
// 풍선의 x, y 값을 [0, 100] (포함은 [], 불포함은 ()) 사이의 랜덤 값으로 설정한다.
// 위치 (50, 50)에서 반경 20의 영향을 미치는 폭탄이 터졌다.
// 폭탄의 영향권에 있는 풍선의 정보를 출력하라.
//		풍선(x, y)
// 전체 영향받은 풍선의 개수를 출력하라.

struct Balloon {	// 8 바이트
	float x;
	float y;
};

struct DrewLine {

};

int main()
{
	default_random_engine dre;
	uniform_int_distribution<> uid{ 0, 100 };
	Balloon balloons [1000];	// 8000 바이트, 1'000'000 바이트까지 사용 가능한 정의 공간
	
	for ( Balloon& b : balloons) {		// 풍선 100개의 랜덤값을 설정함
										// Balloon 안에 있는 걸 원격조종 해야되므로 & 붙여야 됨
		b.x = uid(dre);
		b.y = uid(dre);
	}

	// 풍선 100개와 폭탄의 거리를 계산한다
	int cnt;
	for (const Balloon& b : balloons) {	
		float dx = b.x - 50;
		float dy = b.y - 50;
		
		if (sqrt(dx * dx + dy * dy) <= 20.0) {
			cout << "풍선(" << b.x << ", " << b.y << ")" << endl;
			cnt++;
		}
	}

	cout << "모두 " << cnt << "개의 풍선이 터졌다" << endl;
	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-06 오후 8:41:05 - (금요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 21일 (7주 2일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	- 자료형을 어떻게 만들지?			- struct, class
	- 메모리의 크기는 어떻게 정해지지?	- 속도우선으로 정해짐 
	- 메모리의 값을 어떻게 초기화하지?	- 특별하게(special function)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <string>
#include <random>
#include <algorithm>
#include "save.h"

using namespace std;

// [문제] 풍선 1000개를 생성한다.
// 풍선의 x, y 값을 [0, 100] (포함은 [], 불포함은 ()) 사이의 랜덤 값으로 설정한다.
// 위치 (50, 50)에서 반경 20의 영향을 미치는 폭탄이 터졌다.
// 폭탄의 영향권에 있는 풍선의 정보를 출력하라.
//		풍선(x, y)
// 전체 영향받은 풍선의 개수를 출력하라.

struct Balloon {	// 8 바이트
	float x;
	float y;
};

struct DrewLine {

};

Balloon balloons[10000];	// 80000 바이트

int main()
{
	default_random_engine dre;
	uniform_int_distribution<> uid{ 0, 100 };

	
	for ( Balloon &b : balloons) {		// 풍선 100개의 랜덤값을 설정함
										// Balloon 안에 있는 걸 원격조종 해야되므로 & 붙여야 됨
		b.x = uid(dre);
		b.y = uid(dre);
	}

	// 풍선 100개와 폭탄의 거리를 계산한다
	int cnt;
	for (const Balloon& b : balloons) {		// 메모리 주소 값을 쓸 필요가 없을때 const & 사용
		float dx = b.x - 50;
		float dy = b.y - 50;
		
		if (sqrt(dx * dx + dy * dy) <= 20.0) {
			cout << "풍선(" << b.x << ", " << b.y << ")" << endl;
			cnt++;
		}
	}

	cout << "모두 " << cnt << "개의 풍선이 터졌다" << endl;
	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-06 오후 9:44:16 - (금요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 21일 (7주 2일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	- 자료형을 어떻게 만들지?			- struct, class
	- 메모리의 크기는 어떻게 정해지지?	- 속도우선으로 정해짐 
	- 메모리의 값을 어떻게 초기화하지?	- 특별하게(special function)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age = 1;
	string name = "댕댕이";
};

// [문제] 사용자가 정의한 자료형의 객체(Object)를 초기화하자.

int main()
{
	Dog dog;		// Dog에 존재하는 dog를 객체라고 한다.

	//화면에 "1, 댕댕이"로 출력되도록 하라. (main은 건들지 마라)

	cout << dog.age << ", " << dog.name << endl;

	save("소스.cpp");
}




//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 21일 (7주 2일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	- 자료형을 어떻게 만들지?			- struct, class
	- 메모리의 크기는 어떻게 정해지지?	- 속도우선으로 정해짐 
	- 메모리의 값을 어떻게 초기화하지?	- 특별하게(special function)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age{ 1 };
	string name{ "댕댕이" };
};

// [문제] 사용자가 정의한 자료형의 객체(Object)를 초기화하자.

int main()
{
	int x = 0;

	int n = 0;

	n{ 0 };		// 초기화가 아니다. 처음 이후로 나오는 건 값을 대입하였다, 라고 표현함 (assinment)

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-06 오후 10:20:07 - (금요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 21일 (7주 2일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	- 자료형을 어떻게 만들지?			- struct, class
	- 메모리의 크기는 어떻게 정해지지?	- 속도우선으로 정해짐 
	- 메모리의 값을 어떻게 초기화하지?	- 특별하게(special function)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;

	Dog(int age, string name) : age{ age }, name{ name }	// : age의 값을 전달된 {age}로 함
	{
	}
};

// [문제] 사용자가 정의한 자료형의 객체(Object)를 초기화하자.

int main()
{
	Dog dog{ 1, "댕댕이" };

	// 화면에 "1, 댕댕이"라고 출력되도록 하라
	cout << dog.age << ", " << dog.name << endl;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-06 오후 10:34:10 - (금요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 21일 (7주 2일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	- 자료형을 어떻게 만들지?			- struct, class
	- 메모리의 크기는 어떻게 정해지지?	- 속도우선으로 정해짐 
	- 메모리의 값을 어떻게 초기화하지?	- 특별하게(special function)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;

	Dog(int age, string name) : age{ age }, name{ name } {	// : age의 값을 전달된 {age}로 함
	}

	Dog(string name, int age) : age{ age }, name{ name } {
	}
};

// [문제] 사용자가 정의한 자료형의 객체(Object)를 초기화하자.

int main()
{
	Dog dog1{ 1, "댕댕이" };

	// 화면에 "1, 댕댕이"라고 출력되도록 하라
	cout << dog1.age << ", " << dog1.name << endl;

	Dog dog2{ "쵸코", 2 };
	cout << dog2.age << ", " << dog2.name << endl;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-06 오후 10:38:45 - (금요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 21일 (7주 2일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	- 자료형을 어떻게 만들지?			- struct, class
	- 메모리의 크기는 어떻게 정해지지?	- 속도우선으로 정해짐 
	- 메모리의 값을 어떻게 초기화하지?	- 특별하게(special function)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age = 3;
	string name = "코코";
};

// [문제] 사용자가 정의한 자료형의 객체(Object)를 초기화하자.

int main()
{

	// [문제] Dog3의 나이는 3, 이름은 "코코"
	Dog dog3;
	cout << dog3.age << ", " << dog3.name << endl;
	
	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-06 오후 10:39:59 - (금요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 21일 (7주 2일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	- 자료형을 어떻게 만들지?			- struct, class
	- 메모리의 크기는 어떻게 정해지지?	- 속도우선으로 정해짐 
	- 메모리의 값을 어떻게 초기화하지?	- 특별하게(special function)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age = 3;
	string name = "코코";

	Dog() {		// default(기본) 생성자
	}

	Dog(int age, string name) : age{ age }, name{ name } {	// : age의 값을 전달된 {age}로 함
	}

	Dog(string name, int age) : age{ age }, name{ name } {
	}
};

// [문제] 사용자가 정의한 자료형의 객체(Object)를 초기화하자.

int main()
{
	Dog dog1{ 1, "댕댕이" };

	// 화면에 "1, 댕댕이"라고 출력되도록 하라
	cout << dog1.age << ", " << dog1.name << endl;

	Dog dog2{ "쵸코", 2 };
	cout << dog2.age << ", " << dog2.name << endl;

	// [문제] Dog3의 나이는 3, 이름은 "코코"
	Dog dog3;
	cout << dog3.age << ", " << dog3.name << endl;
	
	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-06 오후 10:41:08 - (금요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 21일 (7주 2일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	- 자료형을 어떻게 만들지?			- struct, class
	- 메모리의 크기는 어떻게 정해지지?	- 속도우선으로 정해짐 
	- 메모리의 값을 어떻게 초기화하지?	- 특별하게(special function)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age = 3;
	string name = "코코";

	Dog() = default;

	Dog(int age, string name) : age{ age }, name{ name } {	// : age의 값을 전달된 {age}로 함
	}

	Dog(string name, int age) : age{ age }, name{ name } {
	}
};

// [문제] 사용자가 정의한 자료형의 객체(Object)를 초기화하자.

int main()
{
	Dog dog1{ 1, "댕댕이" };

	// 화면에 "1, 댕댕이"라고 출력되도록 하라
	cout << dog1.age << ", " << dog1.name << endl;

	Dog dog2{ "쵸코", 2 };
	cout << dog2.age << ", " << dog2.name << endl;

	// [문제] Dog3의 나이는 3, 이름은 "코코"
	Dog dog3;
	cout << dog3.age << ", " << dog3.name << endl;
	
	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-06 오후 10:47:25 - (금요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 21일 (7주 2일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	- 자료형을 어떻게 만들지?			- struct, class
	- 메모리의 크기는 어떻게 정해지지?	- 속도우선으로 정해짐 
	- 메모리의 값을 어떻게 초기화하지?	- 특별하게(special function)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;

	Dog() {
		cout << "Dog를 디폴트 생성하였다" << endl;
	}
};

// [문제] 사용자가 정의한 자료형의 객체(Object)를 초기화하자.

int main()
{
	int n;
	Dog dog;	// 이 순간에 Dog() 함수가 반드시 호출된다

	
	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-06 오후 10:52:32 - (금요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 21일 (7주 2일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	- 자료형을 어떻게 만들지?			- struct, class
	- 메모리의 크기는 어떻게 정해지지?	- 속도우선으로 정해짐 
	- 메모리의 값을 어떻게 초기화하지?	- 특별하게(special function)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Dog {
	int age;
	string name;

	Dog() {			// 메모리가 생성될 때를 관찰할 수 있음
		cout << "Dog를 디폴트 생성하였다" << endl;
	}

	~Dog() {		// 물결(~) = Tilde, 메모리가 사라질 때를 관찰할 수 있음
		cout << "Dog가 소멸되었다" << endl;
	}
};

// [문제] 사용자가 정의한 자료형의 객체(Object)를 초기화하자.

int main()
{
	Dog dog;	// 이 순간에 Dog() 함수가 반드시 호출된다
	

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-06 오후 11:05:18 - (금요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 26일 (8주 1일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	- 메모리의 값을 어떻게 초기화하지?	- 특별하게(special function)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main()을 수정하지 않고 실행하도록 하라

using Test = int;

int main()
{
	Test a{ 1 };

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-06 오후 11:06:40 - (금요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 26일 (8주 1일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	- 메모리의 값을 어떻게 초기화하지?	- 특별하게(special function)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main()을 수정하지 않고 실행하도록 하라
// Test는 사용자가 정의한 자료형이다.

struct Test {
	int n;
};

int main()
{
	Test a{ 1 };

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-06 오후 11:08:19 - (금요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 26일 (8주 1일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	- 메모리의 값을 어떻게 초기화하지?	- 특별하게(special function)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main()을 수정하지 않고 실행하도록 하라
// Test는 사용자가 정의한 자료형이다.

struct Test {
	Test(int) {};
};

int main()
{
	Test a{ 1 };

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-06 오후 11:18:14 - (금요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 26일 (8주 1일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	- 메모리의 값을 어떻게 초기화하지?	- 특별하게(special function)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main()을 수정하지 않고 실행하도록 하라
// Test는 사용자가 정의한 자료형이다.
// show() 결과가 의도대로 출력되어야 한다.
// 객체의 생성과 소멸을 관찰해 보자.

struct Test {
	int n{ -1 };

	Test(int n) : n{ n } {
	}

	void show() {
		cout << "Test::show() - " << n << endl;
	}

	Test() {
		cout << "객체가 생성되었다" << endl;
	}

	~Test() {
		cout << "객체가 소멸되었다" << endl;
	}
};

int main()
{
	{
		Test a;
		a.show();		// Test::show() - -1
	}
	{
		Test a{ 123 };
		a.show();		// Test::show() - 123
	}
	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-06 오후 11:44:23 - (금요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 26일 (8주 1일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	- 메모리의 값을 어떻게 초기화하지?	- 특별하게(special function)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main()을 수정하지 않고 실행하도록 하라
// Test는 사용자가 정의한 자료형이다.
// show() 결과가 의도대로 출력되어야 한다.
// 객체의 생성과 소멸을 관찰해 보자.

struct Test {
	int n;

	Test() : n{ -1 } {
		cout << "디폴트 생성" << endl;
	}

	Test(int n) : n{ n } {
		cout << "Test(int) 생성" << endl;
	}

	void show() {
		cout << "Test::show() - " << n << endl;
	}

	~Test() {
		cout << "Test 소멸 - " << n << endl;
	}
};

int main()
{
	cout << "---- 메인 시작 ----" << endl;
	Test a{ 123 };
	save("소스.cpp");
	cout << "--- 메인 끝 ----" << endl;
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-06 오후 11:46:14 - (금요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 26일 (8주 1일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	- 메모리의 값을 어떻게 초기화하지?	- 특별하게(special function)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main()을 수정하지 않고 실행하도록 하라
// Test는 사용자가 정의한 자료형이다.
// show() 결과가 의도대로 출력되어야 한다.
// 객체의 생성과 소멸을 관찰해 보자.

struct Test {
	int n;

	Test() : n{ -1 } {
		cout << "디폴트 생성" << endl;
	}

	Test(int n) : n{ n } {
		cout << "Test(int) 생성" << endl;
	}

	void show() {
		cout << "Test::show() - " << n << endl;
	}

	~Test() {
		cout << "Test 소멸 - " << n << endl;
	}
};

int main()
{
	cout << "---- 메인 시작 ----" << endl;
	{
		Test a{ 123 };
	}
	save("소스.cpp");
	cout << "--- 메인 끝 ----" << endl;
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-06 오후 11:48:21 - (금요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 26일 (8주 1일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	- 메모리의 값을 어떻게 초기화하지?	- 특별하게(special function)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main()을 수정하지 않고 실행하도록 하라
// Test는 사용자가 정의한 자료형이다.
// show() 결과가 의도대로 출력되어야 한다.
// 객체의 생성과 소멸을 관찰해 보자.

struct Test {
	int n;

	Test() : n{ -1 } {
		cout << "디폴트 생성" << endl;
	}

	Test(int n) : n{ n } {
		cout << "Test(int) 생성" << endl;
	}

	void show() {
		cout << "Test::show() - " << n << endl;
	}

	~Test() {
		cout << "Test 소멸 - " << n << endl;
	}
};

int main()
{
	cout << "---- 메인 시작 ----" << endl;
	Test{ 123 };
	save("소스.cpp");
	cout << "--- 메인 끝 ----" << endl;
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-06 오후 11:48:42 - (금요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 26일 (8주 1일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	- 메모리의 값을 어떻게 초기화하지?	- 특별하게(special function)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main()을 수정하지 않고 실행하도록 하라
// Test는 사용자가 정의한 자료형이다.
// show() 결과가 의도대로 출력되어야 한다.
// 객체의 생성과 소멸을 관찰해 보자.

struct Test {
	int n;

	Test() : n{ -1 } {
		cout << "디폴트 생성" << endl;
	}

	Test(int n) : n{ n } {
		cout << "Test(int) 생성" << endl;
	}

	void show() {
		cout << "Test::show() - " << n << endl;
	}

	~Test() {
		cout << "Test 소멸 - " << n << endl;
	}
};

int main()
{
	cout << "---- 메인 시작 ----" << endl;
	(Test{ 123 }).show();
	save("소스.cpp");
	cout << "--- 메인 끝 ----" << endl;
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-06 오후 11:49:37 - (금요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 26일 (8주 1일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	- 메모리의 값을 어떻게 초기화하지?	- 특별하게(special function)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main()을 수정하지 않고 실행하도록 하라
// Test는 사용자가 정의한 자료형이다.
// show() 결과가 의도대로 출력되어야 한다.
// 객체의 생성과 소멸을 관찰해 보자.

struct Test {
	int n;

	Test() : n{ -1 } {
		cout << "디폴트 생성" << endl;
	}

	Test(int n) : n{ n } {
		cout << "Test(int) 생성" << endl;
	}

	void show() {
		cout << "Test::show() - " << n << endl;
	}

	~Test() {
		cout << "Test 소멸 - " << n << endl;
	}
};

Test a{ 1 };

int main()
{
	cout << "---- 메인 시작 ----" << endl;
	save("소스.cpp");
	cout << "--- 메인 끝 ----" << endl;
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-06 오후 11:50:18 - (금요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 26일 (8주 1일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	- 메모리의 값을 어떻게 초기화하지?	- 특별하게(special function)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main()을 수정하지 않고 실행하도록 하라
// Test는 사용자가 정의한 자료형이다.
// show() 결과가 의도대로 출력되어야 한다.
// 객체의 생성과 소멸을 관찰해 보자.

struct Test {
	int n;

	Test() : n{ -1 } {
		cout << "디폴트 생성" << endl;
	}

	Test(int n) : n{ n } {
		cout << "Test(int) 생성" << endl;
	}

	void show() {
		cout << "Test::show() - " << n << endl;
	}

	~Test() {
		cout << "Test 소멸 - " << n << endl;
	}
};

int main()
{
	cout << "---- 메인 시작 ----" << endl;
	{
		static Test a{ 1 };
	}
	save("소스.cpp");
	cout << "--- 메인 끝 ----" << endl;
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-07 오전 12:01:39 - (토요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 26일 (8주 1일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	예) calss Test라면

C++ 언어는 필요에 따라 6개의 special 함수를 만든다.
	1. Test()				- default constructor, 생성
	2. ~Test()				- destructor, 소멸
	3. Test( const Test& )	- copy constructor
	4. Test& operator=( const Test& ) - copy assignment operator
	5. Test( Test&& )		- move constructor
	6. Test& operator=( Test&& ) - move assignment operator

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Test {
	Test() = default;		// delete로 하면 Test() 못 씀
	~Test() = default;
	Test(const Test&) = default;
	Test& operator=(const Test&) = default;
	Test(Test&&) = default;
	Test& operator=(Test&&) = default;
};

// [문제] main()을 수정하지 않고 실행하도록 하라
// Test는 사용자가 정의한 자료형이다.
// show() 결과가 의도대로 출력되어야 한다.
// 객체의 생성과 소멸을 관찰해 보자.


int main()
{
	Test a;		// Test();를 호출

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-07 오전 12:03:30 - (토요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 26일 (8주 1일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	예) calss Test라면

C++ 언어는 필요에 따라 6개의 special 함수를 만든다.
	1. Test()				- default constructor, 생성
	2. ~Test()				- destructor, 소멸
	3. Test( const Test& )	- copy constructor
	4. Test& operator=( const Test& ) - copy assignment operator
	5. Test( Test&& )		- move constructor
	6. Test& operator=( Test&& ) - move assignment operator

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Test {
	Test() = default;		// delete로 하면 Test() 못 씀
	~Test() = default;
	Test(const Test&) = default;
	Test& operator=(const Test&) = default;
	Test(Test&&) = default;
	Test& operator=(Test&&) = default;
};

// [문제] main()을 수정하지 않고 실행하도록 하라
// Test는 사용자가 정의한 자료형이다.
// show() 결과가 의도대로 출력되어야 한다.
// 객체의 생성과 소멸을 관찰해 보자.


int main()
{
	Test a;
	Test b;

	Test c = a; // 복사생성, 세번째 거
	b = c;		// 복사대입, 네번째 거

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-07 오전 12:05:36 - (토요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 26일 (8주 1일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	예) calss Test라면

C++ 언어는 필요에 따라 6개의 special 함수를 만든다.
	1. Test()				- default constructor, 생성
	2. ~Test()				- destructor, 소멸
	3. Test( const Test& )	- copy constructor
	4. Test& operator=( const Test& ) - copy assignment operator
	5. Test( Test&& )		- move constructor
	6. Test& operator=( Test&& ) - move assignment operator

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <string>
#include "save.h"
using namespace std;

struct Test {
	Test() = default;		// delete로 하면 Test() 못 씀
	~Test() = default;
	Test(const Test&) = default;
	Test& operator=(const Test&) = default;
	Test(Test&&) = default;
	Test& operator=(Test&&) = default;
};

// [문제] main()을 수정하지 않고 실행하도록 하라
// Test는 사용자가 정의한 자료형이다.
// show() 결과가 의도대로 출력되어야 한다.
// 객체의 생성과 소멸을 관찰해 보자.


int main()
{
	string s1{ "C++언어에서 문자열 처리는 이걸로" };
	string s2 = s1;

	cout << "s1 - " << s1 << endl;
	cout << "s2 - " << s2 << endl;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-07 오전 12:06:18 - (토요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 26일 (8주 1일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	예) calss Test라면

C++ 언어는 필요에 따라 6개의 special 함수를 만든다.
	1. Test()				- default constructor, 생성
	2. ~Test()				- destructor, 소멸
	3. Test( const Test& )	- copy constructor
	4. Test& operator=( const Test& ) - copy assignment operator
	5. Test( Test&& )		- move constructor
	6. Test& operator=( Test&& ) - move assignment operator

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <string>
#include "save.h"
using namespace std;

struct Test {
	Test() = default;		// delete로 하면 Test() 못 씀
	~Test() = default;
	Test(const Test&) = default;
	Test& operator=(const Test&) = default;
	Test(Test&&) = default;
	Test& operator=(Test&&) = default;
};

// [문제] main()을 수정하지 않고 실행하도록 하라
// Test는 사용자가 정의한 자료형이다.
// show() 결과가 의도대로 출력되어야 한다.
// 객체의 생성과 소멸을 관찰해 보자.


int main()
{
	string s1{ "C++언어에서 문자열 처리는 이걸로" };
	string s2 = move(s1);

	cout << "s1 - " << s1 << endl;
	cout << "s2 - " << s2 << endl;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-07 오전 12:07:21 - (토요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 26일 (8주 1일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	예) calss Test라면

C++ 언어는 필요에 따라 6개의 special 함수를 만든다.
	1. Test()				- default constructor, 생성
	2. ~Test()				- destructor, 소멸
	3. Test( const Test& )	- copy constructor
	4. Test& operator=( const Test& ) - copy assignment operator
	5. Test( Test&& )		- move constructor
	6. Test& operator=( Test&& ) - move assignment operator

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <string>
#include "save.h"
using namespace std;

struct Test {
	Test() = default;		// delete로 하면 Test() 못 씀
	~Test() = default;
	Test(const Test&) = default;
	Test& operator=(const Test&) = default;
	Test(Test&&) = default;
	Test& operator=(Test&&) = default;
};

// [문제] main()을 수정하지 않고 실행하도록 하라
// Test는 사용자가 정의한 자료형이다.
// show() 결과가 의도대로 출력되어야 한다.
// 객체의 생성과 소멸을 관찰해 보자.


int main()
{
	string s1{ "C++언어에서 문자열 처리는 이걸로" };
	string s2 = static_cast<string&&>(s1);		// 이동. 정식표기지만 잘 안 씀 move(s1)을 더 씀

	cout << "s1 - " << s1 << endl;
	cout << "s2 - " << s2 << endl;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-07 오전 12:10:06 - (토요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 26일 (8주 1일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	예) calss Test라면

C++ 언어는 필요에 따라 6개의 special 함수를 만든다.
	1. Test()				- default constructor, 생성
	2. ~Test()				- destructor, 소멸
	3. Test( const Test& )	- copy constructor
	4. Test& operator=( const Test& ) - copy assignment operator
	5. Test( Test&& )		- move constructor
	6. Test& operator=( Test&& ) - move assignment operator

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <string>
#include "save.h"
using namespace std;

struct Point3D { float x; float y; float z; };

struct Dog {
	int age;
	Point3D vertex[1000];
};

int main()
{
	Dog a;
	cout << sizeof(Dog) << endl;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-07 오전 12:19:32 - (토요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 26일 (8주 1일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	예) calss Test라면

C++ 언어는 필요에 따라 6개의 special 함수를 만든다.
	1. Test()				- default constructor, 생성
	2. ~Test()				- destructor, 소멸
	3. Test( const Test& )	- copy constructor
	4. Test& operator=( const Test& ) - copy assignment operator
	5. Test( Test&& )		- move constructor
	6. Test& operator=( Test&& ) - move assignment operator

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Point3D { float x; float y; float z; };

struct Dog {
	int age;
	Point3D vertex[1000];

	Dog(int age) : age{ age } {
		cout << "생성 - " << age << endl;
	}

	void show() {
		cout << "Dog - " << age << endl;
	}

	~Dog() {
		cout << "소멸 - " << age << endl;
	}
};

// [중요문제] main을 수정하지 않는다.
// Dog의 생성과 소멸을 관찰하라.
// (확인) 생성과 소멸의 짝이 맞는지 확인한다.
// show() 함수는 나이를 제대로 출력해야 한다. (1, 2, 3)

int main()
{
	Dog dogs[3]{ 1, 2, 3 };
	
	for (Dog dog : dogs)
		dog.show();

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-07 오전 12:20:42 - (토요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 26일 (8주 1일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	예) calss Test라면

C++ 언어는 필요에 따라 6개의 special 함수를 만든다.
	1. Test()				- default constructor, 생성
	2. ~Test()				- destructor, 소멸
	3. Test( const Test& )	- copy constructor
	4. Test& operator=( const Test& ) - copy assignment operator
	5. Test( Test&& )		- move constructor
	6. Test& operator=( Test&& ) - move assignment operator

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Point3D { float x; float y; float z; };

struct Dog {
	int age;
	Point3D vertex[1000];

	Dog(int age) : age{ age } {
		cout << "생성 - " << age << endl;
	}

	void show() {
		cout << "Dog - " << age << endl;
	}

	~Dog() {
		cout << "소멸 - " << age << endl;
	}
};

// [중요문제] main을 수정하지 않는다.
// Dog의 생성과 소멸을 관찰하라.
// (확인) 생성과 소멸의 짝이 맞는지 확인한다.
// show() 함수는 나이를 제대로 출력해야 한다. (1, 2, 3)

int main()
{
	Dog dogs[3]{ 1, 2, 3 };
	
	cout << "***************************" << endl;
	for (Dog dog : dogs)
		dog.show();
	cout << "***************************" << endl;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-07 오전 12:23:03 - (토요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 26일 (8주 1일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	예) calss Test라면

C++ 언어는 필요에 따라 6개의 special 함수를 만든다.
	1. Test()				- default constructor, 생성
	2. ~Test()				- destructor, 소멸
	3. Test( const Test& )	- copy constructor
	4. Test& operator=( const Test& ) - copy assignment operator
	5. Test( Test&& )		- move constructor
	6. Test& operator=( Test&& ) - move assignment operator

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Point3D { float x; float y; float z; };

struct Dog {
	int age;
	Point3D vertex[1000];

	Dog(int age) : age{ age } {
		cout << "생성 - " << age << endl;
	}

	void show() {
		cout << "Dog - " << age << endl;
	}

	~Dog() {
		cout << "소멸 - " << age << endl;
	}
};

// [중요문제] main을 수정하지 않는다.
// Dog의 생성과 소멸을 관찰하라.
// (확인) 생성과 소멸의 짝이 맞는지 확인한다.
// show() 함수는 나이를 제대로 출력해야 한다. (1, 2, 3)

int main()
{
	Dog dogs[3]{ 1, 2, 3 };
	
	cout << "***************************" << endl;
//	for (Dog dog : dogs)
	for (int i = 0; i < 3; ++i) {
		Dog dog = dogs[i];
		dog.show();
	}
	cout << "***************************" << endl;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-07 오전 12:25:32 - (토요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 26일 (8주 1일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	예) calss Test라면

C++ 언어는 필요에 따라 6개의 special 함수를 만든다.
	1. Test()				- default constructor, 생성
	2. ~Test()				- destructor, 소멸
	3. Test( const Test& )	- copy constructor
	4. Test& operator=( const Test& ) - copy assignment operator
	5. Test( Test&& )		- move constructor
	6. Test& operator=( Test&& ) - move assignment operator

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Point3D { float x; float y; float z; };

struct Dog {
	int age;
	Point3D vertex[1000];

	Dog(int age) : age{ age } {
		cout << "생성 - " << age << endl;
	}

	void show() {
		cout << "Dog - " << age << endl;
	}

	~Dog() {
		cout << "소멸 - " << age << endl;
	}
};

// [중요문제] main을 수정하지 않는다.
// Dog의 생성과 소멸을 관찰하라.
// (확인) 생성과 소멸의 짝이 맞는지 확인한다.
// show() 함수는 나이를 제대로 출력해야 한다. (1, 2, 3)

int main()
{
	Dog dogs[3]{ 1, 2, 3 };
	
	cout << "***************************" << endl;
//	for (Dog dog : dogs)
	for (int i = 0; i < 3; ++i) {
		Dog& dog = dogs[i];
		dog.show();
	}
	cout << "***************************" << endl;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-07 오전 12:28:25 - (토요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 26일 (8주 1일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	예) calss Test라면

C++ 언어는 필요에 따라 6개의 special 함수를 만든다.
	1. Test()				- default constructor, 생성
	2. ~Test()				- destructor, 소멸
	3. Test( const Test& )	- copy constructor
	4. Test& operator=( const Test& ) - copy assignment operator
	5. Test( Test&& )		- move constructor
	6. Test& operator=( Test&& ) - move assignment operator

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Point3D { float x; float y; float z; };

struct Dog {
	int age;
	Point3D vertex[1000];

	Dog(int age) : age{ age } {
		cout << "생성 - " << age << endl;
	}

	void show() {
		cout << "Dog - " << age << endl;
	}

	~Dog() {
		cout << "소멸 - " << age << endl;
	}

	Dog(const Dog& other) : age{ other.age } {
		cout << "복사생성자 - " << age << endl;
	}

};



// [중요문제] main을 수정하지 않는다.
// Dog의 생성과 소멸을 관찰하라.
// (확인) 생성과 소멸의 짝이 맞는지 확인한다.
// show() 함수는 나이를 제대로 출력해야 한다. (1, 2, 3)

int main()
{
	Dog dogs[3]{ 1, 2, 3 };
	
	cout << "***************************" << endl;
	for (Dog dog : dogs)
		dog.show();
	cout << "***************************" << endl;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-07 오전 12:32:37 - (토요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 26일 (8주 1일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	예) calss Test라면

C++ 언어는 필요에 따라 6개의 special 함수를 만든다.
	1. Test()				- default constructor, 생성
	2. ~Test()				- destructor, 소멸
	3. Test( const Test& )	- copy constructor
	4. Test& operator=( const Test& ) - copy assignment operator
	5. Test( Test&& )		- move constructor
	6. Test& operator=( Test&& ) - move assignment operator

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Point3D { float x; float y; float z; };

struct Dog {
	int age;
	Point3D vertex[1000];

	Dog(int age) : age{ age } {
		cout << "생성 - " << age << endl;
	}

	void show() {
		cout << "Dog - " << age << endl;
	}

	~Dog() {
		cout << "소멸 - " << age << endl;
	}

	Dog(const Dog& other) : age{ other.age } {
		cout << "복사생성자 - " << age << endl;
	}

};



// [중요문제] main을 수정하지 않는다.
// Dog의 생성과 소멸을 관찰하라.
// (확인) 생성과 소멸의 짝이 맞는지 확인한다.
// show() 함수는 나이를 제대로 출력해야 한다. (1, 2, 3)

int main()
{
	Dog dogs[3]{ 1, 2, 3 };
	
	cout << "***************************" << endl;
	for (Dog& dog : dogs)	// auto& dog : dogs 도 가능
		dog.show();
	cout << "***************************" << endl;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-07 오전 12:37:14 - (토요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 26일 (8주 1일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	예) calss Test라면

C++ 언어는 필요에 따라 6개의 special 함수를 만든다.
	1. Test()				- default constructor, 생성
	2. ~Test()				- destructor, 소멸
	3. Test( const Test& )	- copy constructor
	4. Test& operator=( const Test& ) - copy assignment operator
	5. Test( Test&& )		- move constructor
	6. Test& operator=( Test&& ) - move assignment operator

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Point3D { float x; float y; float z; };

struct Dog {
	int age;
	Point3D vertex[1000];

	Dog(int age) : age{ age } {
		cout << "생성 - " << age << endl;
	}

	void show() {
		(++++++++++++age)++;
		cout << "Dog - " << age << endl;
	}

	~Dog() {
		cout << "소멸 - " << age << endl;
	}

	Dog(const Dog& other) : age{ other.age } {
		cout << "복사생성자 - " << age << endl;
	}

};



// [중요문제] main을 수정하지 않는다.
// Dog의 생성과 소멸을 관찰하라.
// (확인) 생성과 소멸의 짝이 맞는지 확인한다.
// show() 함수는 나이를 제대로 출력해야 한다. (1, 2, 3)

int main()
{
	Dog dogs[3]{ 1, 2, 3 };
	
	cout << "***************************" << endl;
	for (Dog& dog : dogs) {	// 읽기전용으로만 건든다는 뜻. 값 변경 안 할 것임.
		dog.show();
	}
	cout << "***************************" << endl;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-07 오전 12:39:56 - (토요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 26일 (8주 1일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	예) calss Test라면

C++ 언어는 필요에 따라 6개의 special 함수를 만든다.
	1. Test()				- default constructor, 생성
	2. ~Test()				- destructor, 소멸
	3. Test( const Test& )	- copy constructor
	4. Test& operator=( const Test& ) - copy assignment operator
	5. Test( Test&& )		- move constructor
	6. Test& operator=( Test&& ) - move assignment operator

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Point3D { float x; float y; float z; };

struct Dog {
	int age;
	Point3D vertex[1000];

	Dog(int age) : age{ age } {
		cout << "생성 - " << age << endl;
	}

	void show() const {		// const-qualifier, 읽기전용 자격이 있음(override, volatile도 가능) 
		cout << "Dog - " << age << endl;
	}

	~Dog() {
		cout << "소멸 - " << age << endl;
	}

	Dog(const Dog& other) : age{ other.age } {
		cout << "복사생성자 - " << age << endl;
	}

};



// [중요문제] main을 수정하지 않는다.
// Dog의 생성과 소멸을 관찰하라.
// (확인) 생성과 소멸의 짝이 맞는지 확인한다.
// show() 함수는 나이를 제대로 출력해야 한다. (1, 2, 3)

int main()
{
	Dog dogs[3]{ 1, 2, 3 };
	
	cout << "***************************" << endl;
	for (const Dog& dog : dogs) {	// 읽기전용으로만 건든다는 뜻. 값 변경 안 할 것임. 위에 것과 짝궁임.
		dog.show();
	}
	cout << "***************************" << endl;

	save("소스.cpp");
}



//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-07 오후 10:12:02 - (토요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 26일 (8주 2일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	예) calss Test라면

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] 

int main()
{
	string s1{ "class string은 문자열을 저장하는데 특화되었다" };
	
	cout << s1.size() << endl;	// 몇 글자인지 물어보는 동작
	cout << s1 << endl;			// s1을 화면에 출력해보라

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-07 오후 10:16:47 - (토요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 26일 (8주 2일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	예) calss Test라면

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main을 수정하지 않고 실행시켜야 한다.

using String = string;

int main()
{
	String s1{ "class string은 문자열을 저장하는데 특화되었다" };
	
	cout << s1.size() << endl;	// 몇 글자인지 물어보는 동작
	// cout << s1 << endl;			// s1을 화면에 출력해보라

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-07 오후 10:21:32 - (토요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 26일 (8주 2일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	예) calss Test라면

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main을 수정하지 않고 실행시켜야 한다.

struct String {
	size_t num;

	String(string str) {	// = String(const char*)
		num = str.size();
	};

	size_t size() {			// size_t = 부호가 필요없는 int(unsight int)와 같음
		return num;
	}

};

int main()
{
	String s1{ "class string은 문자열을 저장하는데 특화되었다" };
	
	cout << s1.size() << endl;	// 몇 글자인지 물어보는 동작
	// cout << s1 << endl;			// s1을 화면에 출력해보라

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-07 오후 10:46:31 - (토요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 26일 (8주 2일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	예) calss Test라면

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main을 수정하지 않고 실행시켜야 한다.
// 이미 표준에 있는 string을 사용하지 말자.

struct My_string {
	int num;

	My_string(const char* str) {
		// 전달된 str의 글자수를 센다
		num = strlen(str);

		// 이 글자수를 저장할 수 있는 메모리를 요청한다
		char* p = new char[num];

		// 할당받은 메모리에 전달된 글자를 복사한다 (=memcpy 사용)
		memcpy(p, str, num);
	}

	size_t size() const	{		// const 붙이면 원본 안 건들임
		return num;
	}
};

int main()
{
	My_string s1{ "문자열 저장 전문가" };
	
	cout << s1.size() << endl;	// 몇 글자인지 물어보는 동작
	// cout << s1 << endl;			// s1을 화면에 출력해보라

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-07 오후 10:49:53 - (토요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 26일 (8주 2일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	예) calss Test라면

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main을 수정하지 않고 실행시켜야 한다.
// 이미 표준에 있는 string을 사용하지 말자.

struct My_string {
	int num;
	char* p;

	My_string(const char* str) {
		// 전달된 str의 글자수를 센다
		num = strlen(str);

		// 이 글자수를 저장할 수 있는 메모리를 요청한다
		p = new char[num];

		// 할당받은 메모리에 전달된 글자를 복사한다 (=memcpy 사용)
		memcpy(p, str, num);
	}

	size_t size() const	{		// const 붙이면 원본 안 건들임
		return num;
	}

	void show() const {			// 값을 보여주기만 하고 반환 안 하므로 void
		for ( int i = 0 ; i < num ; ++i )
			cout << p[i];
		cout << endl;
	}
};

int main()
{
	My_string s1{ "문자열 저장 전문가" };
	
	cout << s1.size() << endl;	// 몇 글자인지 물어보는 동작
	s1.show();

	// cout << s1 << endl;			// s1을 화면에 출력해보라

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-07 오후 10:53:11 - (토요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 26일 (8주 2일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	예) calss Test라면

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main을 수정하지 않고 실행시켜야 한다.
// 이미 표준에 있는 string을 사용하지 말자.

struct My_string {
	int num;
	char* p;

	My_string(const char* str) {
		// 전달된 str의 글자수를 센다
		num = strlen(str);

		// 이 글자수를 저장할 수 있는 메모리를 요청한다
		p = new char[num];

		// 할당받은 메모리에 전달된 글자를 복사한다 (=memcpy 사용)
		memcpy(p, str, num);
	}

	~My_string() {
		delete[] p;	// 쓴 번지수를 되돌려준다?
	}

	size_t size() const	{		// const 붙이면 원본 안 건들임
		return num;
	}

	void show() const {			// 값을 보여주기만 하고 반환 안 하므로 void
		for ( int i = 0 ; i < num ; ++i )
			cout << p[i];
		cout << endl;
	}
};

int main()
{
	My_string s1{ "문자열 저장 전문가" };
	
	cout << s1.size() << endl;	// 몇 글자인지 물어보는 동작
	s1.show();

	// cout << s1 << endl;			// s1을 화면에 출력해보라

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-07 오후 11:04:09 - (토요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     10월 26일 (8주 2일)

핵심 질문할 내용

사용자 정의 자료형(User-defined Data Type) : 사용자가 만드는 자료형
	예) calss Test라면

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] main을 수정하지 않고 실행시켜야 한다.
// 이미 표준에 있는 string을 사용하지 말자.

struct My_string {
	int num;
	char* p;

	My_string(const char* str) {
		// 전달된 str의 글자수를 센다
		num = strlen(str);

		// 이 글자수를 저장할 수 있는 메모리를 요청한다
		p = new char[num];

		// 할당받은 메모리에 전달된 글자를 복사한다 (=memcpy 사용)
		memcpy(p, str, num);
	}

	~My_string() {
		delete[] p;	// 쓴 번지수를 되돌려준다?
	}

	size_t size() const	{		// const 붙이면 원본 안 건들임
		return num;
	}

	void show() const {			// 값을 보여주기만 하고 반환 안 하므로 void
		for ( int i = 0 ; i < num ; ++i )
			cout << p[i];
		cout << endl;
	}
};

int main()
{
	My_string s1{ "문자열 저장 전문가" };
	My_string s2 = s1;

	s1.show();
	s2.show();			// ~My_string 때문에 s1이 먼저 없어지기 때문에 s2=s1이 허공에 뜨는 상태가 되어 오류가 뜸
	
	// cout << s1 << endl;			// s1을 화면에 출력해보라

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-07 오후 11:41:03 - (토요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      11월 2일 (9주 1일)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] main을 수정하지 않고 실행시켜야 한다.
// 이미 표준에 있는 string을 사용하지 말자.

struct My_string {
	int num;
	char* p;

	My_string(const char* str) {
		// 전달된 str의 글자수를 센다
		num = strlen(str);

		// 이 글자수를 저장할 수 있는 메모리를 요청한다
		p = new char[num];

		// 할당받은 메모리에 전달된 글자를 복사한다 (=memcpy 사용)
		memcpy(p, str, num);
	}

	~My_string() {
		cout << "소멸자 - " << (void*)p << endl;
		delete[] p;	// 쓴 번지수를 되돌려준다?
	}

	size_t size() const	{		// const 붙이면 원본 안 건들임
		return num;
	}

	void show() const {			// 값을 보여주기만 하고 반환 안 하므로 void
		cout << (void*)p << " --> ";

		for ( int i = 0 ; i < num ; ++i )
			cout << p[i];
		cout << endl;
	}
};

int main()
{
	My_string s1{ "012345678" };
	My_string s2 = s1;

	s1.show();
	s2.show();

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-07 오후 11:57:33 - (토요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      11월 2일 (9주 1일)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] main을 수정하지 않고 실행시켜야 한다.
// 이미 표준에 있는 string을 사용하지 말자.

struct My_string {
	int num;
	char* p;

	My_string(const char* str) {
		// 전달된 str의 글자수를 센다
		num = strlen(str);

		// 이 글자수를 저장할 수 있는 메모리를 요청한다
		p = new char[num];

		// 할당받은 메모리에 전달된 글자를 복사한다 (=memcpy 사용)
		memcpy(p, str, num);
	}

	~My_string() {
		cout << "소멸자 - " << (void*)p << endl;
		delete[] p;	// 쓴 번지수를 되돌려준다?
	}

	My_string(const My_string& 원본) {
		num = 원본.num; // 원본의 num을 내 num으로 대입한다
		p = new char[num]; // num만큼 새 메모리를 요청한다
		memcpy(p, 원본.p, num); // 할당받은 메모리에 원본의 데이터를 복사한다 
	}

	size_t size() const	{		// const 붙이면 원본 안 건들임
		return num;
	}

	void show() const {			// 값을 보여주기만 하고 반환 안 하므로 void
		cout << (void*)p << " --> ";

		for ( int i = 0 ; i < num ; ++i )
			cout << p[i];
		cout << endl;
	}
};

int main()
{
	My_string s1{ "0123456789" };
	My_string s2 = s1;	// s1을 복사하여 s2를 생성한다
				// My_stirng(const My_string& other) <- 원본을 이용하여 복사한다는 뜻
				// 초기화할 기회가 있다.

	s1.show();
	s2.show();

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-08 오전 12:04:17 - (일요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      11월 2일 (9주 1일)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] main을 수정하지 않고 실행시켜야 한다.
// 이미 표준에 있는 string을 사용하지 말자.

struct My_string {
	int num;
	char* p;

	My_string(const char* str) {
		// 전달된 str의 글자수를 센다
		num = strlen(str);

		// 이 글자수를 저장할 수 있는 메모리를 요청한다
		p = new char[num];

		// 할당받은 메모리에 전달된 글자를 복사한다 (=memcpy 사용)
		memcpy(p, str, num);
	}

	~My_string() {
		cout << "소멸자 - " << (void*)p << endl;
		delete[] p;	// 쓴 번지수를 되돌려준다?
	}

	My_string(const My_string& 원본) {
		num = 원본.num; // 원본의 num을 내 num으로 대입한다
		p = new char[num]; // num만큼 새 메모리를 요청한다
		memcpy(p, 원본.p, num); // 할당받은 메모리에 원본의 데이터를 복사한다 
	}

	size_t size() const	{		// const 붙이면 원본 안 건들임
		return num;
	}

	void show() const {			// 값을 보여주기만 하고 반환 안 하므로 void
		cout << (void*)p << " --> ";

		for ( int i = 0 ; i < num ; ++i )
			cout << p[i];
		cout << endl;
	}
};

int main()
{
	My_string s1{ "0123456789" };
	My_string s2 = s1;	// s1을 복사하여 s2를 생성한다
				// My_stirng(const My_string& other) <- 원본을 이용하여 복사한다는 뜻
				// 초기화할 기회가 있다.

	s1.show();
	s2.show();

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-08 오전 12:05:05 - (일요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      11월 2일 (9주 1일)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] main을 수정하지 않고 실행시켜야 한다.
// 이미 표준에 있는 string을 사용하지 말자.

struct My_string {
	int num;
	char* p;

	My_string(const char* str) {
		// 전달된 str의 글자수를 센다
		num = strlen(str);

		// 이 글자수를 저장할 수 있는 메모리를 요청한다
		p = new char[num];

		// 할당받은 메모리에 전달된 글자를 복사한다 (=memcpy 사용)
		memcpy(p, str, num);
	}

	~My_string() {
		cout << "소멸자 - " << (void*)p << endl;
		delete[] p;	// 쓴 번지수를 되돌려준다?
	}

	My_string(const My_string& 원본) {
		num = 원본.num; // 원본의 num을 내 num으로 대입한다
		p = new char[num]; // num만큼 새 메모리를 요청한다
		memcpy(p, 원본.p, num); // 할당받은 메모리에 원본의 데이터를 복사한다 
	}

	size_t size() const	{		// const 붙이면 원본 안 건들임
		return num;
	}

	void show() const {			// 값을 보여주기만 하고 반환 안 하므로 void
		cout << (void*)p << " --> ";

		for ( int i = 0 ; i < num ; ++i )
			cout << p[i];
		cout << endl;
	}
};

int main()
{
	My_string s1{ "0123456789" };
	My_string s2 = s1;	
	My_string s3{ "오늘은 11월 2일 월요일" };

	s1.show();
	s2.show();
	s3.show();

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-08 오전 12:05:23 - (일요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      11월 2일 (9주 1일)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] main을 수정하지 않고 실행시켜야 한다.
// 이미 표준에 있는 string을 사용하지 말자.

struct My_string {
	int num;
	char* p;

	My_string(const char* str) {
		// 전달된 str의 글자수를 센다
		num = strlen(str);

		// 이 글자수를 저장할 수 있는 메모리를 요청한다
		p = new char[num];

		// 할당받은 메모리에 전달된 글자를 복사한다 (=memcpy 사용)
		memcpy(p, str, num);
	}

	~My_string() {
		cout << "소멸자 - " << (void*)p << endl;
		delete[] p;	// 쓴 번지수를 되돌려준다?
	}

	My_string(const My_string& 원본) {
		num = 원본.num; // 원본의 num을 내 num으로 대입한다
		p = new char[num]; // num만큼 새 메모리를 요청한다
		memcpy(p, 원본.p, num); // 할당받은 메모리에 원본의 데이터를 복사한다 
	}

	size_t size() const	{		// const 붙이면 원본 안 건들임
		return num;
	}

	void show() const {			// 값을 보여주기만 하고 반환 안 하므로 void
		cout << (void*)p << " --> ";

		for ( int i = 0 ; i < num ; ++i )
			cout << p[i];
		cout << endl;
	}
};

int main()
{
	My_string s1{ "0123456789" };
	My_string s2 = s1;	
	My_string s3{ "오늘은 11월 2일 월요일" };

	s3 = s1;

	s1.show();
	s2.show();
	s3.show();

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-08 오전 12:20:55 - (일요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      11월 2일 (9주 1일)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] main을 수정하지 않고 실행시켜야 한다.
// 이미 표준에 있는 string을 사용하지 말자.

struct My_string {
	int num;
	char* p;

	My_string(const char* str) {
		// 전달된 str의 글자수를 센다
		num = strlen(str);

		// 이 글자수를 저장할 수 있는 메모리를 요청한다
		p = new char[num];

		// 할당받은 메모리에 전달된 글자를 복사한다 (=memcpy 사용)
		memcpy(p, str, num);
	}

	~My_string() {
		cout << "소멸자 - " << (void*)p << endl;
		delete[] p;	// 쓴 번지수를 되돌려준다?
	}

	// 복사생성자
	My_string(const My_string& 원본) {
		num = 원본.num; // 원본의 num을 내 num으로 대입한다
		p = new char[num]; // num만큼 새 메모리를 요청한다
		memcpy(p, 원본.p, num); // 할당받은 메모리에 원본의 데이터를 복사한다 
	}

	// 복사할당 연산자
	My_string& operator=(const My_string& other) {
		cout << "operator= ";
		this->~My_string();	// this는 나를 가르키는 특수 동작. 나에게 먼저 있던 데이터를 초기화시킴.
		
		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);

		return *this;	// 복사할당 연산자에는 리턴이 이렇게 들어가야 됨. 원본 객체로 돌아간다는 뜻
	}

	size_t size() const	{		// const 붙이면 원본 안 건들임
		return num;
	}

	void show() const {			// 값을 보여주기만 하고 반환 안 하므로 void
		cout << (void*)p << " --> ";

		for ( int i = 0 ; i < num ; ++i )
			cout << p[i];
		cout << endl;
	}
};

int main()
{
	My_string s1{ "0123456789" };
	My_string s2 = s1;	
	My_string s3{ "오늘은 11월 2일 월요일" };

	s3 = s1;		// 프로그램하지 않으면 default = 동작이 실행됨
	// My_string& operator=( const My_string& 원본 );
		// 이 함수에서 깊은 복사가 되도록 코딩해야 한다

	s1.show();
	s2.show();
	s3.show();

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-08 오전 12:57:22 - (일요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      11월 2일 (9주 1일)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include <string>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid_num{ 1, 50 };
uniform_int_distribution<> uid_char{ 'a','z' };

struct My_string {
	int num;
	char* p;

	My_string() {
		num = uid_num(dre);
		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = uid_char(dre);
	}

	My_string(const char* str) {
		// 전달된 str의 글자수를 센다
		num = strlen(str);

		// 이 글자수를 저장할 수 있는 메모리를 요청한다
		p = new char[num];

		// 할당받은 메모리에 전달된 글자를 복사한다 (=memcpy 사용)
		memcpy(p, str, num);
	}

	~My_string() {
		cout << "소멸자 - " << (void*)p << endl;
		delete[] p;	// 쓴 번지수를 되돌려준다?
	}

	// 복사생성자
	My_string(const My_string& 원본) {
		num = 원본.num; // 원본의 num을 내 num으로 대입한다
		p = new char[num]; // num만큼 새 메모리를 요청한다
		memcpy(p, 원본.p, num); // 할당받은 메모리에 원본의 데이터를 복사한다 
	}

	// 복사할당 연산자
	My_string& operator=(const My_string& other) {
		// 나를 나에게 할당하면 안 된다
		if (this == &other) {
			cout << "같은 걸 대입하시려고요?" << endl;
			return *this;
		}
		cout << "operator= ";
		this->~My_string();	// this는 나를 가르키는 특수 동작. 나에게 먼저 있던 데이터를 초기화시킴.
		
		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);

		return *this;	// 복사할당 연산자에는 리턴이 이렇게 들어가야 됨. 원본 객체로 돌아간다는 뜻
	}

	size_t size() const	{		// const 붙이면 원본 안 건들임
		return num;
	}

	void show() const {			// 값을 보여주기만 하고 반환 안 하므로 void
		cout << (void*)p << " --> ";

		for ( int i = 0 ; i < num ; ++i )
			cout << p[i];
		cout << endl;
	}
};

// [문제] My_string을 30개 생성하자.
// default 생성시 글자수는 랜덤으로([1, 50]), 글자는 임의의 알파벳으로 채우자.
// 30개의 My_string을 길이 오름차순으로 정렬하자.
// 잘 되었는지 출력하여 확인하자.

int main()
{
	My_string str[30];

	for ( const My_string& ms : str)	// 읽기만 한다고 const 꼭 붙여줘야 좋음 
		ms.show();

	cout << "정렬하려면 키를 입력하자";
	char ch;
	cin >> ch;

	sort(begin(str), end(str), [](const My_string& a,
		const My_string& b) {
			return a.num < b.num;
		});

	//다시 출력
	for (const My_string& ms : str)
		ms.show();

	cout << "끝내려면 키를 누르시오";
	cin >> ch;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-08 오전 1:02:14 - (일요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      11월 2일 (9주 1일)

사용자가 정의한 자료형에서
	if ( 생성시 자원을 확보했다면 ) {
		소멸자에서 자원을 반환해야 한다
		복사생성자에서 깊은 복사를 해야 한다
		복사할당연산자도 깊은 복사가 되도록 프로그램해야 한다
	}

	else
		아무것도 안해도 된다

int가 하는 것과 같이 각종 연산자를 내가 만든 자료형에서도 사용할 수
있는데 실체는 이건 다 함수를 호출하는 것이었다.

다음시간 - 연산자 오버로딩

struct와 calss는 어떤 차이가 있지?

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include <string>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid_num{ 1, 50 };
uniform_int_distribution<> uid_char{ 'a','z' };

struct My_string {
	int num;
	char* p;

	My_string() {
		num = uid_num(dre);
		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = uid_char(dre);
	}

	My_string(const char* str) {
		// 전달된 str의 글자수를 센다
		num = strlen(str);

		// 이 글자수를 저장할 수 있는 메모리를 요청한다
		p = new char[num];

		// 할당받은 메모리에 전달된 글자를 복사한다 (=memcpy 사용)
		memcpy(p, str, num);
	}

	~My_string() {
		cout << "소멸자 - " << (void*)p << endl;
		delete[] p;	// 쓴 번지수를 되돌려준다?
	}

	// 복사생성자
	My_string(const My_string& 원본) {
		num = 원본.num; // 원본의 num을 내 num으로 대입한다
		p = new char[num]; // num만큼 새 메모리를 요청한다
		memcpy(p, 원본.p, num); // 할당받은 메모리에 원본의 데이터를 복사한다 
	}

	// 복사할당 연산자
	My_string& operator=(const My_string& other) {
		// 나를 나에게 할당하면 안 된다
		if (this == &other) {
			cout << "같은 걸 대입하시려고요?" << endl;
			return *this;
		}
		cout << "operator= ";
		this->~My_string();	// this는 나를 가르키는 특수 동작. 나에게 먼저 있던 데이터를 초기화시킴.
		
		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);

		return *this;	// 복사할당 연산자에는 리턴이 이렇게 들어가야 됨. 원본 객체로 돌아간다는 뜻
	}

	size_t size() const	{		// const 붙이면 원본 안 건들임
		return num;
	}

	void show() const {			// 값을 보여주기만 하고 반환 안 하므로 void
		cout << (void*)p << " --> ";

		for ( int i = 0 ; i < num ; ++i )
			cout << p[i];
		cout << endl;
	}
};

// [문제] My_string을 30개 생성하자.
// default 생성시 글자수는 랜덤으로([1, 50]), 글자는 임의의 알파벳으로 채우자.
// 30개의 My_string을 길이 오름차순으로 정렬하자.
// 잘 되었는지 출력하여 확인하자.

int main()
{
	My_string str[30];

	for ( const My_string& ms : str)	// 읽기만 한다고 const 꼭 붙여줘야 좋음 
		ms.show();

	cout << "정렬하려면 키를 입력하자";
	char ch;
	cin >> ch;

	sort(begin(str), end(str), [](const My_string& a,
		const My_string& b) {
			return a.num < b.num;
		});

	//다시 출력
	for (const My_string& ms : str)
		ms.show();

	cout << "끝내려면 키를 누르시오";
	cin >> ch;

	save("소스.cpp");
}














#include <iostream>
#include <string>
#include <random>

using namespace std;

// 1
/*/
class X {

};

int main()
{
   X a;   // 디폴트 생성자 (X())
   X b;   // 디폴트 생성자 (X())
   X c = a;   // 복사 생성자 (X(const X&))
}
//*/

// 2
/*/
class X {
   int val;
public:
   X(int n) :val(n) {}
   operator int() { return val; }
};

void change(X&, X&);

void change(X& a, X& b)
{
   X temp = a;
   a = b;
   b = temp;
}

int main()
{
   X a = 1, b = 11;

   change(a, b);

   cout << a << "월 " << b << "일" << endl;
}
//*/

// 3~7
/*/
int gid = 1;

uniform_int_distribution<>uid(5, 15);
default_random_engine dre;

class Dog {
   int id = gid++;
   int dist = 0;
public:
   void run() {
      dist += uid(dre);
   }
   int getId() const {
      return id;
   }
   int getDist() const {
      return dist;
   }
};

int main()
{
   Dog* dogs = new Dog[1000];

   // 3
   bool flag = true;

   while (flag) {
      for (int i = 0; i < 1000; ++i)
         dogs[i].run();

      for (int i = 0; i < 1000; ++i)
         if (dogs[i].getDist() >= 1000)
            flag = false;
   }

   // 4
   Dog max = dogs[0];
   for (int i = 0; i < 1000; ++i)
      if (max.getDist() <= dogs[i].getDist())
         max = dogs[i];

   // 5
   cout << max.getId() << ", " << max.getDist() << endl;

   // 6
   // 450, 1002

   // 7
   delete[] dogs;
}
//*/




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-08 오후 9:21:00 - (일요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      11월 4일 (9주 2일)

사용자가 정의한 자료형에서
	if ( 생성시 자원을 확보했다면 ) {
		소멸자에서 자원을 반환해야 한다
		복사생성자에서 깊은 복사를 해야 한다
		복사할당연산자도 깊은 복사가 되도록 프로그램해야 한다
	}

	else
		아무것도 안해도 된다

int가 하는 것과 같이 각종 연산자를 내가 만든 자료형에서도 사용할 수
있는데 실체는 이건 다 함수를 호출하는 것이었다.

다음시간 - 연산자 오버로딩

struct와 calss는 어떤 차이가 있지?

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include <string>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid_num{ 1, 50 };
uniform_int_distribution<> uid_char{ 'a','z' };

struct My_string {
	int num;
	char* p;

	My_string() {
		num = uid_num(dre);
		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = uid_char(dre);
	}

	My_string(const char* str) {
		// 전달된 str의 글자수를 센다
		num = strlen(str);

		// 이 글자수를 저장할 수 있는 메모리를 요청한다
		p = new char[num];

		// 할당받은 메모리에 전달된 글자를 복사한다 (=memcpy 사용)
		memcpy(p, str, num);
	}

	~My_string() {
		cout << "소멸자 - " << (void*)p << endl;
		delete[] p;	// 쓴 번지수를 되돌려준다?
	}

	// 복사생성자
	My_string(const My_string& 원본) {
		num = 원본.num; // 원본의 num을 내 num으로 대입한다
		p = new char[num]; // num만큼 새 메모리를 요청한다
		memcpy(p, 원본.p, num); // 할당받은 메모리에 원본의 데이터를 복사한다 
	}

	// 복사할당 연산자
	My_string& operator=(const My_string& other) {
		// 나를 나에게 할당하면 안 된다
		if (this == &other) {
			cout << "같은 걸 대입하시려고요?" << endl;
			return *this;
		}
		cout << "operator= ";
		this->~My_string();	// this는 나를 가르키는 특수 동작. 나에게 먼저 있던 데이터를 초기화시킴.
		
		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);

		return *this;	// 복사할당 연산자에는 리턴이 이렇게 들어가야 됨. 원본 객체로 돌아간다는 뜻
	}

	size_t size() const	{		// const 붙이면 원본 안 건들임
		return num;
	}

	void show() const {			// 값을 보여주기만 하고 반환 안 하므로 void
		cout << (void*)p << " --> ";

		for ( int i = 0 ; i < num ; ++i )
			cout << p[i];
		cout << endl;
	}
};


// struct와 class는 뭐가 다른 것인가?

int main()
{
	My_string a{ "0123456789" };

	a.show();

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-08 오후 9:25:33 - (일요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      11월 4일 (9주 2일)

사용자가 정의한 자료형에서
	if ( 생성시 자원을 확보했다면 ) {
		소멸자에서 자원을 반환해야 한다
		복사생성자에서 깊은 복사를 해야 한다
		복사할당연산자도 깊은 복사가 되도록 프로그램해야 한다
	}

	else
		아무것도 안해도 된다

int가 하는 것과 같이 각종 연산자를 내가 만든 자료형에서도 사용할 수
있는데 실체는 이건 다 함수를 호출하는 것이었다.

다음시간 - 연산자 오버로딩

struct와 calss는 어떤 차이가 있지?

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include <string>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid_num{ 1, 50 };
uniform_int_distribution<> uid_char{ 'a','z' };

struct My_string {
	int num;
	char* p;

	My_string() {
		num = uid_num(dre);
		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = uid_char(dre);
	}

	My_string(const char* str) {
		// 전달된 str의 글자수를 센다
		num = strlen(str);

		// 이 글자수를 저장할 수 있는 메모리를 요청한다
		p = new char[num];

		// 할당받은 메모리에 전달된 글자를 복사한다 (=memcpy 사용)
		memcpy(p, str, num);
	}

	~My_string() {
		cout << "소멸자 - " << (void*)p << endl;
		delete[] p;	// 쓴 번지수를 되돌려준다?
	}

	// 복사생성자
	My_string(const My_string& 원본) {
		num = 원본.num; // 원본의 num을 내 num으로 대입한다
		p = new char[num]; // num만큼 새 메모리를 요청한다
		memcpy(p, 원본.p, num); // 할당받은 메모리에 원본의 데이터를 복사한다 
	}

	// 복사할당 연산자
	My_string& operator=(const My_string& other) {
		// 나를 나에게 할당하면 안 된다
		if (this == &other) {
			cout << "같은 걸 대입하시려고요?" << endl;
			return *this;
		}
		cout << "operator= ";
		this->~My_string();	// this는 나를 가르키는 특수 동작. 나에게 먼저 있던 데이터를 초기화시킴.
		
		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);

		return *this;	// 복사할당 연산자에는 리턴이 이렇게 들어가야 됨. 원본 객체로 돌아간다는 뜻
	}

	size_t size() const	{		// const 붙이면 원본 안 건들임
		return num;
	}

	void show() const {			// 값을 보여주기만 하고 반환 안 하므로 void
		cout << (void*)p << " --> ";

		for ( int i = 0 ; i < num ; ++i )
			cout << p[i];
		cout << endl;
	}
};


// struct와 class는 뭐가 다른 것인가?

int main()
{
	My_string a{ "0123456789" };

	a.num = 200;

	a.show();

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-08 오후 9:26:33 - (일요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      11월 4일 (9주 2일)

사용자가 정의한 자료형에서
	if ( 생성시 자원을 확보했다면 ) {
		소멸자에서 자원을 반환해야 한다
		복사생성자에서 깊은 복사를 해야 한다
		복사할당연산자도 깊은 복사가 되도록 프로그램해야 한다
	}

	else
		아무것도 안해도 된다

int가 하는 것과 같이 각종 연산자를 내가 만든 자료형에서도 사용할 수
있는데 실체는 이건 다 함수를 호출하는 것이었다.

다음시간 - 연산자 오버로딩

struct와 calss는 어떤 차이가 있지?

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include <string>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid_num{ 1, 50 };
uniform_int_distribution<> uid_char{ 'a','z' };

struct My_string {
	int num;
	char* p;

	My_string() {
		num = uid_num(dre);
		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = uid_char(dre);
	}

	My_string(const char* str) {
		// 전달된 str의 글자수를 센다
		num = strlen(str);

		// 이 글자수를 저장할 수 있는 메모리를 요청한다
		p = new char[num];

		// 할당받은 메모리에 전달된 글자를 복사한다 (=memcpy 사용)
		memcpy(p, str, num);
	}

	~My_string() {
		cout << "소멸자 - " << (void*)p << endl;
		delete[] p;	// 쓴 번지수를 되돌려준다?
	}

	// 복사생성자
	My_string(const My_string& 원본) {
		num = 원본.num; // 원본의 num을 내 num으로 대입한다
		p = new char[num]; // num만큼 새 메모리를 요청한다
		memcpy(p, 원본.p, num); // 할당받은 메모리에 원본의 데이터를 복사한다 
	}

	// 복사할당 연산자
	My_string& operator=(const My_string& other) {
		// 나를 나에게 할당하면 안 된다
		if (this == &other) {
			cout << "같은 걸 대입하시려고요?" << endl;
			return *this;
		}
		cout << "operator= ";
		this->~My_string();	// this는 나를 가르키는 특수 동작. 나에게 먼저 있던 데이터를 초기화시킴.
		
		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);

		return *this;	// 복사할당 연산자에는 리턴이 이렇게 들어가야 됨. 원본 객체로 돌아간다는 뜻
	}

	size_t size() const	{		// const 붙이면 원본 안 건들임
		return num;
	}

	void show() const {			// 값을 보여주기만 하고 반환 안 하므로 void
		cout << (void*)p << " --> ";

		for ( int i = 0 ; i < num ; ++i )
			cout << p[i];
		cout << endl;
	}
};


// struct와 class는 뭐가 다른 것인가?

int main()
{
	My_string a{ "0123456789" };

	a.p = a.p + 2;

	a.show();

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-08 오후 9:31:51 - (일요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      11월 4일 (9주 2일)

사용자가 정의한 자료형에서
	if ( 생성시 자원을 확보했다면 ) {
		소멸자에서 자원을 반환해야 한다
		복사생성자에서 깊은 복사를 해야 한다
		복사할당연산자도 깊은 복사가 되도록 프로그램해야 한다
	}

	else
		아무것도 안해도 된다

int가 하는 것과 같이 각종 연산자를 내가 만든 자료형에서도 사용할 수
있는데 실체는 이건 다 함수를 호출하는 것이었다.

다음시간 - 연산자 오버로딩

struct와 calss는 어떤 차이가 있지?

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include <string>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid_num{ 1, 50 };
uniform_int_distribution<> uid_char{ 'a','z' };

class My_string {
private:						// access specifier. 감추어두기
	int num;					// 저장하고 있는 글자수
	char* p;					// 저장하고 있는 문자의 시작번지

public:
	My_string() {
		num = uid_num(dre);
		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = uid_char(dre);
	}

	My_string(const char* str) {
		// 전달된 str의 글자수를 센다
		num = strlen(str);

		// 이 글자수를 저장할 수 있는 메모리를 요청한다
		p = new char[num];

		// 할당받은 메모리에 전달된 글자를 복사한다 (=memcpy 사용)
		memcpy(p, str, num);
	}

	~My_string() {
		cout << "소멸자 - " << (void*)p << endl;
		delete[] p;	// 쓴 번지수를 되돌려준다?
	}

	// 복사생성자
	My_string(const My_string& 원본) {
		num = 원본.num; // 원본의 num을 내 num으로 대입한다
		p = new char[num]; // num만큼 새 메모리를 요청한다
		memcpy(p, 원본.p, num); // 할당받은 메모리에 원본의 데이터를 복사한다 
	}

	// 복사할당 연산자
	My_string& operator=(const My_string& other) {
		// 나를 나에게 할당하면 안 된다
		if (this == &other) {
			cout << "같은 걸 대입하시려고요?" << endl;
			return *this;
		}
		cout << "operator= ";
		this->~My_string();	// this는 나를 가르키는 특수 동작. 나에게 먼저 있던 데이터를 초기화시킴.
		
		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);

		return *this;	// 복사할당 연산자에는 리턴이 이렇게 들어가야 됨. 원본 객체로 돌아간다는 뜻
	}

	size_t size() const	{		// const 붙이면 원본 안 건들임
		return num;
	}

	void show() const {			// 값을 보여주기만 하고 반환 안 하므로 void
		cout << (void*)p << " --> ";

		for ( int i = 0 ; i < num ; ++i )
			cout << p[i];
		cout << endl;
	}
};


// struct와 class는 뭐가 다른 것인가?
// class는 감추어둘 수 있음. 변경 불가, access 불가.
// public으로 해야 쓸 수 있음

int main()
{
	My_string a{ "0123456789" };	// [10][번지]

	a.show();

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-08 오후 9:41:44 - (일요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      11월 4일 (9주 2일)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include "save.h"

#include <windows.h>
#include <mmsystem.h>			// wave 파일
#pragma comment(lib,"winmm.lib")
using namespace std;

class Dog {
public:
	Dog() {
		cout << "Dog 메모리가 만들어진 후 이 함수가 호출됨" << endl;
		PlaySound( L"개짖는소리.wav", 0, SND_FILENAME | SND_SYNC);
	}

	~Dog() {

	}
};

int main()
{
	Dog dog;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-08 오후 9:48:25 - (일요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      11월 4일 (9주 2일)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include "save.h"

#include <windows.h>
#include <mmsystem.h>			// wave 파일
#pragma comment(lib,"winmm.lib")
using namespace std;

class Dog {
public:
	Dog() {
		cout << "Dog 메모리가 만들어진 후 이 함수가 호출됨" << endl;
		PlaySound( L"개짖는소리.wav", 0, SND_FILENAME | SND_SYNC);
	}

	~Dog() {
		PlaySound(L"비명.wav", 0, SND_FILENAME | SND_SYNC);
	}
};

int main()
{
	Dog dog;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-08 오후 9:50:40 - (일요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      11월 4일 (9주 2일)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include "save.h"

#include <windows.h>
#include <mmsystem.h>			// wave 파일
#pragma comment(lib,"winmm.lib")
using namespace std;

class Dog {
public:
	Dog() {
		cout << "Dog 메모리가 만들어진 후 이 함수가 호출됨" << endl;
		PlaySound( L"개짖는소리.wav", 0, SND_FILENAME | SND_SYNC);
	}

	~Dog() {
		PlaySound(L"비명.wav", 0, SND_FILENAME | SND_SYNC);
	}
};

int main()
{
	Dog dog[2];

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-08 오후 9:54:48 - (일요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      11월 4일 (9주 2일)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include "save.h"

#include <windows.h>
#include <mmsystem.h>			// wave 파일
#pragma comment(lib,"winmm.lib")
using namespace std;

class Dog {
public:
	Dog() {
		PlaySound( L"개짖는소리.wav", 0, SND_FILENAME | SND_SYNC);
	}

	Dog(const Dog&) {			// 복사생성자
		PlaySound(L"복사.wav", 0, SND_FILENAME | SND_SYNC);
	}

	~Dog() {
		PlaySound(L"마리오.wav", 0, SND_FILENAME | SND_SYNC);
	}
};

int main()
{
	Dog* p = new Dog;

	save("소스.cpp");

	delete p;
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-08 오후 9:56:29 - (일요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      11월 4일 (9주 2일)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include "save.h"

#include <windows.h>
#include <mmsystem.h>			// wave 파일
#pragma comment(lib,"winmm.lib")
using namespace std;

class Dog {
public:
	Dog() {
		PlaySound( L"개짖는소리.wav", 0, SND_FILENAME | SND_SYNC);
	}

	Dog(const Dog&) {			// 복사생성자
		PlaySound(L"복사.wav", 0, SND_FILENAME | SND_SYNC);
	}

	~Dog() {
		PlaySound(L"마리오.wav", 0, SND_FILENAME | SND_SYNC);
	}
};

int main()
{
	Dog* p = new Dog;		// 얘가 먼저 소멸됨. 딜리트 때문에.

	Dog a = *p;	

	save("소스.cpp");

	delete p;
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-08 오후 9:58:12 - (일요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      11월 4일 (9주 2일)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include "save.h"

#include <windows.h>
#include <mmsystem.h>			// wave 파일
#pragma comment(lib,"winmm.lib")
using namespace std;

class Dog {
public:
	Dog() {
		PlaySound( L"개짖는소리.wav", 0, SND_FILENAME | SND_SYNC);
	}

	Dog(const Dog&) {			// 복사생성자
		PlaySound(L"복사.wav", 0, SND_FILENAME | SND_SYNC);
	}

	~Dog() {
		PlaySound(L"마리오.wav", 0, SND_FILENAME | SND_SYNC);
	}

};

void f(Dog) { }

int main()
{
	Dog dog;

	f(dog);

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-08 오후 9:58:47 - (일요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      11월 4일 (9주 2일)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include "save.h"

#include <windows.h>
#include <mmsystem.h>			// wave 파일
#pragma comment(lib,"winmm.lib")
using namespace std;

class Dog {
public:
	Dog() {
		PlaySound( L"개짖는소리.wav", 0, SND_FILENAME | SND_SYNC);
	}

	Dog(const Dog&) {			// 복사생성자
		PlaySound(L"복사.wav", 0, SND_FILENAME | SND_SYNC);
	}

	~Dog() {
		PlaySound(L"마리오.wav", 0, SND_FILENAME | SND_SYNC);
	}

};

void f(Dog&) { }		// & 붙이면 복사되지 않음

int main()
{
	Dog dog;

	f(dog);

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-08 오후 10:00:27 - (일요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      11월 4일 (9주 2일)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include "save.h"

#include <windows.h>
#include <mmsystem.h>			// wave 파일
#pragma comment(lib,"winmm.lib")
using namespace std;

class Dog {
public:
	Dog() {
		PlaySound( L"개짖는소리.wav", 0, SND_FILENAME | SND_SYNC);
	}

	Dog(const Dog&) {			// 복사생성자
		PlaySound(L"복사.wav", 0, SND_FILENAME | SND_SYNC);
	}

	~Dog() {
		PlaySound(L"마리오.wav", 0, SND_FILENAME | SND_SYNC);
	}

};

Dog f(Dog& a) {	// & 붙이면 복사되지 않음. 해당코드는 올때는 복사하지 않지만 a를 리턴하기위해 복사를 함
	return a;
}		

int main()
{
	Dog dog;

	f(dog);

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-08 오후 10:00:57 - (일요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      11월 4일 (9주 2일)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include "save.h"

#include <windows.h>
#include <mmsystem.h>			// wave 파일
#pragma comment(lib,"winmm.lib")
using namespace std;

class Dog {
public:
	Dog() {
		PlaySound( L"개짖는소리.wav", 0, SND_FILENAME | SND_SYNC);
	}

	Dog(const Dog&) {			// 복사생성자
		PlaySound(L"복사.wav", 0, SND_FILENAME | SND_SYNC);
	}

	~Dog() {
		PlaySound(L"마리오.wav", 0, SND_FILENAME | SND_SYNC);
	}

};

Dog& f(Dog& a) {	// 둘 다 & 붙이면 둘 다 복사하지 않음
	return a;
}		

int main()
{
	Dog dog;

	f(dog);

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-08 오후 10:02:54 - (일요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      11월 4일 (9주 2일)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include "save.h"

#include <windows.h>
#include <mmsystem.h>			// wave 파일
#pragma comment(lib,"winmm.lib")
using namespace std;

class Dog {
public:
	Dog() {
		PlaySound( L"개짖는소리.wav", 0, SND_FILENAME | SND_SYNC);
	}

	Dog(const Dog&) {			// 복사생성자
		PlaySound(L"복사.wav", 0, SND_FILENAME | SND_SYNC);
	}

	~Dog() {
		PlaySound(L"마리오.wav", 0, SND_FILENAME | SND_SYNC);
	}

};

Dog& f(Dog& a) {	// 둘 다 & 붙이면 둘 다 복사하지 않음
	return a;
}		

int main()
{
	Dog dog[2];

	for (Dog a : dog)
		;

	save("소스.cpp");
}

// 이 코드는 생성 2번, 생성 1번/소멸 1번, 생성 1번/소멸 1번, 소멸 2번




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-08 오후 10:03:29 - (일요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      11월 4일 (9주 2일)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include "save.h"

#include <windows.h>
#include <mmsystem.h>			// wave 파일
#pragma comment(lib,"winmm.lib")
using namespace std;

class Dog {
public:
	Dog() {
		PlaySound( L"개짖는소리.wav", 0, SND_FILENAME | SND_SYNC);
	}

	Dog(const Dog&) {			// 복사생성자
		PlaySound(L"복사.wav", 0, SND_FILENAME | SND_SYNC);
	}

	~Dog() {
		PlaySound(L"마리오.wav", 0, SND_FILENAME | SND_SYNC);
	}

};

Dog& f(Dog& a) {	// 둘 다 & 붙이면 둘 다 복사하지 않음
	return a;
}		

int main()
{
	Dog dog[2];

	for (const Dog& a : dog)
		;

	save("소스.cpp");
}

// 이 코드는 생성 2번, 생성 1번/소멸 1번, 생성 1번/소멸 1번, 소멸 2번
// 복사 안 하려면 const & 붙여줘야 함




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-08 오후 10:09:17 - (일요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      11월 4일 (9주 2일)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include "save.h"

#include <windows.h>
#include <mmsystem.h>			// wave 파일
#pragma comment(lib,"winmm.lib")
using namespace std;

int main()
{
	cout.operator<<( 1 );

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-08 오후 10:11:48 - (일요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      11월 4일 (9주 2일)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

int main()
{
	// cout << 1 << 2 << endl;
	
	((cout.operator<<(1)).operator<<(2)).operator<<(endl);
	
	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-08 오후 10:39:25 - (일요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      11월 4일 (9주 2일)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] int와 유사하게 동작하는 class INT를 만들며 연산자 오버로딩을 연습

class INT {
	int num{ 0 };

public:
	INT() = default;
	INT(int n) : num{ n } {
	}

	// getter 코딩
	int getNum() const {		// 누군가가 너의 값을 가져가길 원할 때
		return num;
	}

	void show() const {
		cout << num << endl;
	}
};

// [1] 연산자를 전역함수로 구현

INT operator+( const INT&, const INT&);		// 맨앞 INT에도 &를 붙이면 a+b의 값을 복사해와야 하는데 건들지 못하는 웃긴 상황이 됨, 함수선언

INT operator+(const INT& lhs, const INT& rhs)	// lhs(left hand side)
{
	return int {lhs.getNum() + rhs.getNum()};
}

//			a			+			b 
//		operand 	operator     operand
//				binary operator
//  				이항 연산자
// ++a;
// ++(a);
// unary operator (단항 연산자)

int main()
{
	INT a{ 0 };		// a의 값은 0
	INT b{3};		// b의 값은 3

	INT c = a + b;	// c의 값은 3

	// a + b를 cpp 컴파일러는 어떻게 해석할까? -> 함수를 찾는다
	// operator+( INT, INT )

	c.show();

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-08 오후 10:39:59 - (일요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      11월 4일 (9주 2일)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] int와 유사하게 동작하는 class INT를 만들며 연산자 오버로딩을 연습

class INT {
	int num{ 0 };

public:
	INT() = default;
	INT(int n) : num{ n } {
	}

	// getter 코딩
	int getNum() const {		// 누군가가 너의 값을 가져가길 원할 때
		return num;
	}

	void show() const {
		cout << num << endl;
	}
};

// [1] 연산자를 전역함수로 구현

INT operator+( const INT&, const INT&);		// 맨앞 INT에도 &를 붙이면 a+b의 값을 복사해와야 하는데 건들지 못하는 웃긴 상황이 됨, 함수선언

INT operator+(const INT& lhs, const INT& rhs)	// lhs(left hand side)
{
	return int {lhs.getNum() + rhs.getNum()};
}

int main()
{
	INT a{ 0 };	
	INT b{3};	

	INT c = a + b + b + b + b + a;	

	c.show();

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-08 오후 10:40:59 - (일요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      11월 4일 (9주 2일)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] int와 유사하게 동작하는 class INT를 만들며 연산자 오버로딩을 연습

class INT {
	int num{ 0 };

public:
	INT() = default;
	INT(int n) : num{ n } {
	}

	// getter 코딩
	int getNum() const {		// 누군가가 너의 값을 가져가길 원할 때
		return num;
	}

	void show() const {
		cout << num << endl;
	}
};

// [1] 연산자를 전역함수로 구현

INT operator+( const INT&, const INT&);		// 맨앞 INT에도 &를 붙이면 a+b의 값을 복사해와야 하는데 건들지 못하는 웃긴 상황이 됨, 함수선언

INT operator+(const INT& lhs, const INT& rhs)	// lhs(left hand side)
{
	return int {lhs.getNum() + rhs.getNum()};
}

int main()
{
	INT a{ 0 };	
	INT b{3};	

	INT c = INT(INT(INT(a + b) + b) + b);	

	c.show();

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-08 오후 10:46:29 - (일요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      11월 4일 (9주 2일)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] int와 유사하게 동작하는 class INT를 만들며 연산자 오버로딩을 연습

class INT {
	int num{ 0 };

public:
	INT() = default;
	INT(int n) : num{ n } {
	}

	void show() const {
		cout << num << endl;
	}

	INT operator + (const INT & rhs) const {	//getNum 필요없음
		return INT{ num + rhs.num };
	}
};

// [1] 전역함수, 여기 말고도 쓸 데가 많을 때 사용함
	// INT operator+(const INT&, const INT&);
	// int prinf( const char*, ... ); <- 대표적인 전역함수

// [2] 연산자를 멤버함수로 구현. operator는 멤버함수로 만듬. class 속에다 만듬 

int main()
{
	INT a{ 0 };	
	INT b{3};	

	INT c = INT(INT(INT(a + b) + b) + b);	

	c.show();

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-08 오후 10:48:54 - (일요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      11월 4일 (9주 2일)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] int와 유사하게 동작하는 class INT를 만들며 연산자 오버로딩을 연습

class INT {
	int num{ 0 };

public:
	INT() = default;
	INT() = default;
	INT(int n) : num{ n } {
	}

	void show() const {
		cout << num << endl;
	}

	INT operator + (const INT & rhs) const {	//getNum 필요없음
		return INT{ num + rhs.num };
	}
};

// 단항연산자. 

int main()
{
	int a = 1;

	cout << ++a << endl;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-08 오후 10:49:04 - (일요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      11월 4일 (9주 2일)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] int와 유사하게 동작하는 class INT를 만들며 연산자 오버로딩을 연습

class INT {
	int num{ 0 };

public:
	INT() = default;
	INT(int n) : num{ n } {
	}

	void show() const {
		cout << num << endl;
	}

	INT operator + (const INT & rhs) const {	//getNum 필요없음
		return INT{ num + rhs.num };
	}
};

// 단항연산자. 

int main()
{
	int a = 1;

	cout << a++ << endl;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-08 오후 10:50:32 - (일요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      11월 4일 (9주 2일)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] int와 유사하게 동작하는 class INT를 만들며 연산자 오버로딩을 연습

class INT {
	int num{ 0 };

public:
	INT() = default;
	INT(int n) : num{ n } {
	}

	void show() const {
		cout << num << endl;
	}

	INT operator + (const INT & rhs) const {	//getNum 필요없음
		return INT{ num + rhs.num };
	}
};

// 단항연산자. 

int main()
{
	int a = 1;

	cout << - ++ ++ ++a << endl;		// -4 , a++ ++ ++ 는 안 됨

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-08 오후 10:52:43 - (일요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                      11월 4일 (9주 2일)

 시험2 예정 - 11월 9일 (월요일 10주 1일) */
//-------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] int와 유사하게 동작하는 class INT를 만들며 연산자 오버로딩을 연습

class INT {
	int num{ 0 };

public:
	INT() = default;
	INT(int n) : num{ n } {
	}

	void show() const {
		cout << num << endl;
	}

	INT operator + (const INT & rhs) const {	//getNum 필요없음
		return INT{ num + rhs.num };
	}


};

// 단항연산자. 
// ++a;		a.operator++( ), 나 자신을 사용하는 함수니까 인자 더 필요없음

int main()
{
	int a = 1;

//	cout << (++a).show() << endl;		// -4 , a++ ++ ++ 는 안 됨
//	cout << (a++).show() << endl;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-09 오후 1:42:28 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 9일 (10주 1일)

 시험2 - 11월 9일 */
//-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class MemoryMonster {


public:
	int num[100]{ 100 };

	void show() const {
		cout << "MemoryMonster - int의 개수 : " << sizeof(num)/4 << ", int의 값 : " << num[0] << endl;

	}
};

int main()
{
	MemoryMonster mm;

	mm.show();

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-09 오후 1:54:00 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 9일 (10주 1일)

 시험2 - 11월 9일 */
//-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class MemoryMonster {
	int num{ 0 };
	int* p{ 0 };

public:
	MemoryMonster() {
		int num[100]{ 100 };
	};

	MemoryMonster(const MemoryMonster& org) {
		num = org.num; // 원본의 num을 내 num으로 대입한다
		p = new int[num]; // num만큼 새 메모리를 요청한다
		memcpy(p, org.p, num); // 할당받은 메모리에 원본의 데이터를 복사한다 
	}

	void show() const {
		cout << "MemoryMonster - int의 개수 : " << sizeof(num)/4 << ", int의 값 : " << num << endl;

	}
};

int main()
{
	MemoryMonster mm1;
	MemoryMonster mm2 = mm1;

	mm1.show();
	mm2.show();

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-09 오후 1:55:22 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 9일 (10주 1일)

 시험2 - 11월 9일 */
//-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class MemoryMonster {

public:
	int num{ 0 };
	int* p{ 0 };

	MemoryMonster() {
		int num[100]{ 100 };
	}

	MemoryMonster(const MemoryMonster& org) {
		num = org.num; // 원본의 num을 내 num으로 대입한다
		p = new int[num]; // num만큼 새 메모리를 요청한다
		memcpy(p, org.p, num); // 할당받은 메모리에 원본의 데이터를 복사한다 
	}

	void show() const {
		cout << "MemoryMonster - int의 개수 : " << sizeof(num)/4 << ", int의 값 : " << num << endl;

	}
};

int main()
{
	MemoryMonster mm1;
	MemoryMonster mm2 = mm1;

	mm1.show();
	mm2.show();

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-09 오후 1:59:30 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 9일 (10주 1일)

 시험2 - 11월 9일 */
//-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class MemoryMonster {
	int num{ 0 };
	int* p{ 0 };

public:
	MemoryMonster() {
		int num{ 100 };
		p = new int[num];
	}

	MemoryMonster(const MemoryMonster& org) {
		num = org.num; // 원본의 num을 내 num으로 대입한다
		p = new int[num]; // num만큼 새 메모리를 요청한다
		memcpy(p, org.p, num); // 할당받은 메모리에 원본의 데이터를 복사한다 
	}

	void show() const {
		cout << "MemoryMonster - int의 개수 : " << sizeof(num)/4 << ", int의 값 : " << num << endl;

	}
};

int main()
{
	MemoryMonster mm1;
	MemoryMonster mm2 = mm1;

	mm1.show();
	mm2.show();

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-09 오후 2:06:39 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 9일 (10주 1일)

 시험2 - 11월 9일 */
//-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class MemoryMonster {

public:
	int num{ 0 };
	int* p{ 0 };

	MemoryMonster() {
		int num[100]{ 100 };
	}

	MemoryMonster(const MemoryMonster& org) {
		num = org.num; // 원본의 num을 내 num으로 대입한다
		p = new int[num]; // num만큼 새 메모리를 요청한다
		memcpy(p, org.p, num); // 할당받은 메모리에 원본의 데이터를 복사한다 
	}

	void show() const {
		cout << "MemoryMonster - int의 개수 : " << sizeof(num)/4 << ", int의 값 : " << num << endl;

	}
};

int main()
{
	MemoryMonster mm1;
	MemoryMonster mm2 = mm1;

	mm1.show();
	mm2.show();

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-09 오후 2:09:08 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 9일 (10주 1일)

 시험2 - 11월 9일 */
//-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class MemoryMonster {

public:
	int num{ 0 };
	char* p{ 0 };

	MemoryMonster() {
		int num[100]{ 100 };
	}

	MemoryMonster(const MemoryMonster& org) {
		int num{ 100 };
		num = org.num; // 원본의 num을 내 num으로 대입한다
		p = new char[num]; // num만큼 새 메모리를 요청한다
		memcpy(p, org.p, num); // 할당받은 메모리에 원본의 데이터를 복사한다 
	}

	void show() const {
		cout << "MemoryMonster - int의 개수 : " << sizeof(num)/4 << ", int의 값 : " << num << endl;

	}
};

int main()
{
	MemoryMonster mm1;
	MemoryMonster mm2 = mm1;

	mm1.show();
	mm2.show();

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-09 오후 2:11:02 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 9일 (10주 1일)

 시험2 - 11월 9일 */
//-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class MemoryMonster {

public:
	int num[100]{ 100 };
	char* p;

	MemoryMonster() {
		int num;
	}

	//MemoryMonster(const MemoryMonster& org) {
		//int num{ 100 };
		//num = org.num; // 원본의 num을 내 num으로 대입한다
		//p = new char[num]; // num만큼 새 메모리를 요청한다
		//memcpy(p, org.p, num); // 할당받은 메모리에 원본의 데이터를 복사한다 
	//}

	void show() const {
		cout << "MemoryMonster - int의 개수 : " << sizeof(num)/4 << ", int의 값 : " << num << endl;

	}
};

int main()
{
	MemoryMonster mm1;
	MemoryMonster mm2 = mm1;

	mm1.show();
	mm2.show();

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-09 오후 2:11:31 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 9일 (10주 1일)

 시험2 - 11월 9일 */
//-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class MemoryMonster {

public:
	int num[100]{ 100 };
	char* p;

	MemoryMonster() {
		int num;
	}

	//MemoryMonster(const MemoryMonster& org) {
		//int num{ 100 };
		//num = org.num; // 원본의 num을 내 num으로 대입한다
		//p = new char[num]; // num만큼 새 메모리를 요청한다
		//memcpy(p, org.p, num); // 할당받은 메모리에 원본의 데이터를 복사한다 
	//}

	void show() const {
		cout << "MemoryMonster - int의 개수 : " << sizeof(num)/4 << ", int의 값 : " << num[0] << endl;

	}
};

int main()
{
	MemoryMonster mm1;
	MemoryMonster mm2 = mm1;

	mm1.show();
	mm2.show();

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-09 오후 2:16:00 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 9일 (10주 1일)

 시험2 - 11월 9일 */
//-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class MemoryMonster {

public:
	int num[100];
	char* p;

	MemoryMonster() {
		int num[100]{ 100 };
	}

	MemoryMonster(const MemoryMonster& org) {
		int num{ 100 };
		p = new char[num]; // num만큼 새 메모리를 요청한다
		memcpy(p, org.p, num); // 할당받은 메모리에 원본의 데이터를 복사한다 
	}

	void show() const {
		cout << "MemoryMonster - int의 개수 : " << sizeof(num)/4 << ", int의 값 : " << num[0] << endl;

	}
};

int main()
{
	MemoryMonster mm1;
	MemoryMonster mm2 = mm1;

	mm1.show();
	mm2.show();

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-09 오후 2:17:11 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 9일 (10주 1일)

 시험2 - 11월 9일 */
//-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class MemoryMonster {

public:
	int num[100];
	char* p;

	MemoryMonster() {
		int num[100]{ 100 };
	}

	MemoryMonster(const MemoryMonster& org) {
		int num{ 100 };
		p = new char[num]; // num만큼 새 메모리를 요청한다
		memcpy(p, org.p, num); // 할당받은 메모리에 원본의 데이터를 복사한다 
	}

	void show() const {
		cout << "MemoryMonster - int의 개수 : " << sizeof(num)/4 << ", int의 값 : " << num[0] << endl;

	}
};

int main()
{
	MemoryMonster mm1;
	MemoryMonster mm2 = mm1;

	mm1.show();
	mm2.show();

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-09 오후 2:21:51 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 9일 (10주 1일)

 시험2 - 11월 9일 */
//-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class MemoryMonster {

public:
	int num[100];
	char* p;

	MemoryMonster() {
		int num[100]{ 100 };
	}

	MemoryMonster(const MemoryMonster& org) {
		int num{ 100 };
		p = new char[num]; // num만큼 새 메모리를 요청한다
		memcpy(p, org.p, num); // 할당받은 메모리에 원본의 데이터를 복사한다 
	}

	void show() const {
		cout << "MemoryMonster - int의 개수 : " << sizeof(num)/4 << ", int의 값 : " << num[0] << endl;

	}
};

int main()
{
	MemoryMonster mm1;
	MemoryMonster mm2 = mm1;

	mm1.show();
	mm2.show();

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-09 오후 2:23:41 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 9일 (10주 1일)

 시험2 - 11월 9일 */
//-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class MemoryMonster {

public:
	int num[100];
	char* p;

	MemoryMonster() {
		int num[100]{ 100 };
	}

	MemoryMonster(const MemoryMonster& org) {
		int num{ 100 };
		p = new char[num]; // num만큼 새 메모리를 요청한다
		memcpy(p, org.p, num); // 할당받은 메모리에 원본의 데이터를 복사한다 
	}

	void show() const {
		cout << "MemoryMonster - int의 개수 : " << sizeof(num)/4 << ", int의 값 : " << num[0] << endl;

	}
};

int main()
{
	MemoryMonster mm1;
	MemoryMonster mm2 = mm1;

	mm1.show();
	mm2.show();

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-09 오후 2:24:11 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 9일 (10주 1일)

 시험2 - 11월 9일 */
//-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class MemoryMonster {

public:
	int num[100];
	int* p;

	MemoryMonster() {
		int num[100]{ 100 };
	}

	MemoryMonster(const MemoryMonster& org) {
		int num{ 100 };
		p = new int[num]; // num만큼 새 메모리를 요청한다
		memcpy(p, org.p, num); // 할당받은 메모리에 원본의 데이터를 복사한다 
	}

	void show() const {
		cout << "MemoryMonster - int의 개수 : " << sizeof(num)/4 << ", int의 값 : " << num[0] << endl;

	}
};

int main()
{
	MemoryMonster mm1;
	MemoryMonster mm2 = mm1;

	mm1.show();
	mm2.show();

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-09 오후 2:26:33 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 9일 (10주 1일)

 시험2 - 11월 9일 */
//-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class MemoryMonster {

public:
	int num[100];
	int* p;

	MemoryMonster() {
		int num[100]{ 100 };
	}

	MemoryMonster(const MemoryMonster& org) {
		int num{ 100 };
		p = new int[num]; // num만큼 새 메모리를 요청한다
		memcpy(p, org.p, num); // 할당받은 메모리에 원본의 데이터를 복사한다 
	}

	MemoryMonster& operator=(const MemoryMonster& other) {
		int num{ 100 };
		cout << "operator= ";
		this->~MemoryMonster();	// this는 나를 가르키는 특수 동작. 나에게 먼저 있던 데이터를 초기화시킴.
		p = new int[num];
		memcpy(p, other.p, num);

		return *this;	// 복사할당 연산자에는 리턴이 이렇게 들어가야 됨. 원본 객체로 돌아간다는 뜻
	}

	void show() const {
		cout << "MemoryMonster - int의 개수 : " << sizeof(num)/4 << ", int의 값 : " << num[0] << endl;

	}
};

int main()
{
	MemoryMonster mm1;
	MemoryMonster mm2 = mm1;

	mm1.show();
	mm2.show();

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-09 오후 2:36:21 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 9일 (10주 1일)

 시험2 - 11월 9일 */
//-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class MemoryMonster {

public:
	int num[100];
	int* p;

	MemoryMonster() {
		int num[100]{ 100 };
	}

	MemoryMonster(const MemoryMonster& org) {
		int num{ 100 };
		p = new int[num]; // num만큼 새 메모리를 요청한다
		memcpy(p, org.p, num); // 할당받은 메모리에 원본의 데이터를 복사한다 
	}

	MemoryMonster& operator=(const MemoryMonster& other) {
		int num{ 100 };
		this->~MemoryMonster();	// this는 나를 가르키는 특수 동작. 나에게 먼저 있던 데이터를 초기화시킴.
		p = new int[num];
		memcpy(p, other.p, num);

		return *this;	// 복사할당 연산자에는 리턴이 이렇게 들어가야 됨. 원본 객체로 돌아간다는 뜻
	}

	void show() const {
		cout << "MemoryMonster - int의 개수 : " << sizeof(num)/4 << ", int의 값 : " << num[0] << endl;

	}
};

int main()
{
	MemoryMonster mm1;
	MemoryMonster mm2 = mm1;

	mm1.show();
	mm2.show();

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-09 오후 2:37:06 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 9일 (10주 1일)

 시험2 - 11월 9일 */
//-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class MemoryMonster {

public:
	int num[100];
	int* p;

	MemoryMonster() {
		int num[100]{ 100 };
	}

	MemoryMonster(const MemoryMonster& org) {
		int num{ 100 };
		p = new int[num]; // num만큼 새 메모리를 요청한다
		memcpy(p, org.p, num); // 할당받은 메모리에 원본의 데이터를 복사한다 
	}

	MemoryMonster& operator=(MemoryMonster) {
		int num{ 100 };
		this->~MemoryMonster();	// this는 나를 가르키는 특수 동작. 나에게 먼저 있던 데이터를 초기화시킴.
		p = new int[num];
		//memcpy(p, other.p, num);

		return *this;	// 복사할당 연산자에는 리턴이 이렇게 들어가야 됨. 원본 객체로 돌아간다는 뜻
	}

	void show() const {
		cout << "MemoryMonster - int의 개수 : " << sizeof(num)/4 << ", int의 값 : " << num[0] << endl;

	}
};

int main()
{
	MemoryMonster mm1;
	MemoryMonster mm2 = mm1;

	mm1.show();
	mm2.show();

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-09 오후 2:37:19 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 9일 (10주 1일)

 시험2 - 11월 9일 */
//-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class MemoryMonster {

public:
	int num[100];
	int* p;

	MemoryMonster() {
		int num[100]{ 100 };
	}

	MemoryMonster(const MemoryMonster& org) {
		int num{ 100 };
		p = new int[num]; // num만큼 새 메모리를 요청한다
		memcpy(p, org.p, num); // 할당받은 메모리에 원본의 데이터를 복사한다 
	}

	MemoryMonster& operator=(MemoryMonster) {
		int num{ 100 };
		this->~MemoryMonster();	// this는 나를 가르키는 특수 동작. 나에게 먼저 있던 데이터를 초기화시킴.
		p = new int[num];
		memcpy(p, p, num);

		return *this;	// 복사할당 연산자에는 리턴이 이렇게 들어가야 됨. 원본 객체로 돌아간다는 뜻
	}

	void show() const {
		cout << "MemoryMonster - int의 개수 : " << sizeof(num)/4 << ", int의 값 : " << num[0] << endl;

	}
};

int main()
{
	MemoryMonster mm1;
	MemoryMonster mm2 = mm1;

	mm1.show();
	mm2.show();

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-09 오후 2:38:48 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 9일 (10주 1일)

 시험2 - 11월 9일 */
//-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class MemoryMonster {

public:
	int num[100];
	int* p;

	MemoryMonster() {
		int num[100]{ 100 };
	}

	MemoryMonster(const MemoryMonster& org) {
		int num{ 100 };
		p = new int[num]; // num만큼 새 메모리를 요청한다
		memcpy(p, org.p, num); // 할당받은 메모리에 원본의 데이터를 복사한다 
	}

	MemoryMonster& operator=(const MemoryMonster& other) {
		int num{ 100 };
		this->~MemoryMonster();	// this는 나를 가르키는 특수 동작. 나에게 먼저 있던 데이터를 초기화시킴.
		p = new int[num];
		memcpy(p, other.p, num);

		return *this;	// 복사할당 연산자에는 리턴이 이렇게 들어가야 됨. 원본 객체로 돌아간다는 뜻
	}

	void show() const {
		cout << "MemoryMonster - int의 개수 : " << sizeof(num)/4 << ", int의 값 : " << num[0] << endl;

	}

	void special() {

	}
};

int main()
{
	MemoryMonster mm;

	for (int i = 0; i < 10; ++i)
		mm.special();

	mm.show();

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-09 오후 2:43:23 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 9일 (10주 1일)

 시험2 - 11월 9일 */
//-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class MemoryMonster {

public:
	int num[100];
	int* p;

	MemoryMonster() {
		int num[100]{ 100 };
	}

	MemoryMonster(const MemoryMonster& org) {
		int num{ 100 };
		p = new int[num]; // num만큼 새 메모리를 요청한다
		memcpy(p, org.p, num); // 할당받은 메모리에 원본의 데이터를 복사한다 
	}

	MemoryMonster& operator=(const MemoryMonster& other) {
		int num{ 100 };
		this->~MemoryMonster();	// this는 나를 가르키는 특수 동작. 나에게 먼저 있던 데이터를 초기화시킴.
		p = new int[num];
		memcpy(p, other.p, num);

		return *this;	// 복사할당 연산자에는 리턴이 이렇게 들어가야 됨. 원본 객체로 돌아간다는 뜻
	}

	void show() const {
		cout << "MemoryMonster - int의 개수 : " << sizeof(num)/4 << ", int의 값 : " << num[0] << endl;

	}

	int special(){
		int	num[102400]{ 102400 };
		return 0;
	}
};

int main()
{
	MemoryMonster mm;

	for (int i = 0; i < 10; ++i)
		mm.special();

	mm.show();

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-09 오후 2:43:36 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 9일 (10주 1일)

 시험2 - 11월 9일 */
//-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class MemoryMonster {

public:
	int num[100];
	int* p;

	MemoryMonster() {
		int num[100]{ 100 };
	}

	MemoryMonster(const MemoryMonster& org) {
		int num{ 100 };
		p = new int[num]; // num만큼 새 메모리를 요청한다
		memcpy(p, org.p, num); // 할당받은 메모리에 원본의 데이터를 복사한다 
	}

	MemoryMonster& operator=(const MemoryMonster& other) {
		int num{ 100 };
		this->~MemoryMonster();	// this는 나를 가르키는 특수 동작. 나에게 먼저 있던 데이터를 초기화시킴.
		p = new int[num];
		memcpy(p, other.p, num);

		return *this;	// 복사할당 연산자에는 리턴이 이렇게 들어가야 됨. 원본 객체로 돌아간다는 뜻
	}

	void show() const {
		cout << "MemoryMonster - int의 개수 : " << sizeof(num)/4 << ", int의 값 : " << num[0] << endl;

	}

	void special(){
		int	num[102400]{ 102400 };
	}
};

int main()
{
	MemoryMonster mm;

	for (int i = 0; i < 10; ++i)
		mm.special();

	mm.show();

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-11 오전 11:53:00 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 11일 (10주 2일)

 시험2 - 11월 9일(월) 10주 1일 ---> 확인 */
 //-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;


// 문제 1번
class MemoryMonster {
	size_t num;		// int의 개수 (음수값 없음)
	int* p;

public:
	MemoryMonster() : num{ 100 }, p{ new int[100] } {
		// num = 100;
		// p = new int[num] {100};	// 할당 받는다는 것은 new. new일 때 메모리를 반환 가능함.

		for (int i = 0; i < 100; ++i)
			p[i] = 100;
	}

	~MemoryMonster() {
		delete[] p;
	}

	void show() const {
		cout << "MemoryMonster - int의 개수 : " << num << ", int의 값 : " << p[0] << endl;
	}
};

int main()
{
	MemoryMonster mm;

	mm.show();

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-11 오후 12:02:17 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 11일 (10주 2일)

 시험2 - 11월 9일(월) 10주 1일 ---> 확인 */
 //-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;


// 문제 1번
class MemoryMonster {
	size_t num;		// int의 개수 (음수값 없음)
	int* p;

public:
	MemoryMonster() : num{ 100 }, p{ new int[100] } {
		// num = 100;
		// p = new int[num] {100};	// 할당 받는다는 것은 new. new일 때 메모리를 반환 가능함.

		for (int i = 0; i < 100; ++i)
			p[i] = 100;
	}

	~MemoryMonster() {		// 짝을 맞춰서 꼭 써야됨
		delete[] p;
	}

	MemoryMonster(const MemoryMonster& other)		// 문제 2번의 답
		: num{ other.num }, p{ new int[num] } {
		for (int i = 0; i < num; ++i)
			p[i] = other.p[i] + 1;
	}

	void show() const {
		cout << "MemoryMonster - int의 개수 : " << num << ", int의 값 : " << p[0] << endl;
	}
};

int main()
{
	MemoryMonster mm1;
	MemoryMonster mm2{ mm1 };		// 복사생성

	mm1.show();
	mm2.show();

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-11 오후 12:12:13 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 11일 (10주 2일)

 시험2 - 11월 9일(월) 10주 1일 ---> 확인 */
 //-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;


// 문제 1번
class MemoryMonster {
	size_t num;		// int의 개수 (음수값 없음)
	int* p;

public:
	MemoryMonster() : num{ 100 }, p{ new int[100] } {
		// num = 100;
		// p = new int[num] {100};	// 할당 받는다는 것은 new. new일 때 메모리를 반환 가능함.

		for (int i = 0; i < 100; ++i)
			p[i] = 100;
	}

	~MemoryMonster() {		// 짝을 맞춰서 꼭 써야됨
		delete[] p;
	}

	// 클래스의 public 멤버에 복사생정자를 함수에 추가한다. 문제 2번.
	MemoryMonster(const MemoryMonster& other)
		: num{ other.num }, p{ new int[num] } {
		for (int i = 0; i < num; ++i)
			p[i] = other.p[i] + 1;
	}

	void show() const {
		cout << "MemoryMonster - int의 개수 : " << num << ", int의 값 : " << p[0] << endl;
	}

	// 3번 문제. 메모리 2배 만들기.
	void special() {		// [100][번지 p]
		// 이미 확보한 메모리를 해제한다
		delete[] p;
		// 개수를 2배로 만든다
		num *= 2;
		// 2배 메모리를 잡는다
		p = new int[num];
		// 값을 쓴다
		for (int i = 0; i < num; ++i)
			p[i] = num;
	}
};

int main()
{
	MemoryMonster mm;

	for (int i = 0; i < 10; ++i)
		mm.special();

	mm.show();

	save("소스.cpp");
}





//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 11일 (10주 2일)

 시험2 - 11월 9일(월) 10주 1일 ---> 확인 */
 //-------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;


// 문제 1번
class MemoryMonster {
	size_t num;		// int의 개수 (음수값 없음)
	int* p;

public:
	MemoryMonster() : num{ 100 }, p{ new int[100] } {
		// num = 100;
		// p = new int[num] {100};	// 할당 받는다는 것은 new. new일 때 메모리를 반환 가능함.

		for (int i = 0; i < 100; ++i)
			p[i] = 100;
	}

	~MemoryMonster() {		// 짝을 맞춰서 꼭 써야됨
		delete[] p;
	}

	// 클래스의 public 멤버에 복사생정자를 함수에 추가한다. 문제 2번.
	MemoryMonster(const MemoryMonster& other)
		: num{ other.num }, p{ new int[num] } {
		for (int i = 0; i < num; ++i)
			p[i] = other.p[i] + 1;
	}

	MemoryMonster& operator=(const MemoryMonster& other) {
		if (this == &other)
			return *this;
		delete[] p;
		num = other.num;
		p = new int[num];
		for (int i = 0; i < num; ++i)
			p[i] = other.p[i];

		return *this;
	}

	void show() const {
		cout << "MemoryMonster - int의 개수 : " << num << ", int의 값 : " << p[0] << endl;
	}

	// 3번 문제. 메모리 2배 만들기.
	void special() {		// [100][번지 p]
		// 이미 확보한 메모리를 해제한다
		delete[] p;
		// 개수를 2배로 만든다
		num *= 2;
		// 2배 메모리를 잡는다
		p = new int[num];
		// 값을 쓴다
		for (int i = 0; i < num; ++i)
			p[i] = num;
	}

	size_t getNum() const {
		return num;
	}
};

int main()
{
	MemoryMonster monsters[10];

	default_random_engine dre;
	uniform_int_distribution<> uid{ 1, 10 };

	for (MemoryMonster& mm : monsters) {
		int num = uid(dre);
		for (int i = 0; i < num; ++i)
			mm.special();
	}

	// 문제 4, 여기에 들어갈 정렬코드를 답지에 써라

	sort(begin(monsters), end(monsters), 
		[](const MemoryMonster& a, const MemoryMonster& b) {
			a.getNum() < b.getNum();
		});

	for (MemoryMonster& mm : monsters)
		mm.show();

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-11 오후 12:33:30 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 11일 (10주 2일)

 시험2 - 11월 9일(월) 10주 1일 ---> 확인 */
 //-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

int main()
{
	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-11 오후 12:48:07 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 11일 (10주 2일)

연산자 오버로딩 */
 //-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;


int main()
{
	int a[10];		// 0, 1, 2, 3, 4, 5, 6, 7, 8, 9

	cout << a[-1] << endl;	// 이게 가능한 이유는 꿀문법이기 때문
	cout << a[10] << endl;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-11 오후 12:48:38 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 11일 (10주 2일)

연산자 오버로딩 */
 //-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;


int main()
{
	int a[10];		// 0, 1, 2, 3, 4, 5, 6, 7, 8, 9

	cout << *(a + -1) << endl;	// 이게 가능한 이유는 꿀문법이기 때문
	cout << *(a + 10) << endl;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-11 오후 1:02:45 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 11일 (10주 2일)

연산자 오버로딩 */
 //-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class SafeIntArray {
	size_t num;
	int* p;

public:
	SafeIntArray(size_t n) : num{ n } {	// num은 size_t라서 n도 size_t로 맞추어준다
		p = new int[num] {};		// 배열 저장. 0으로 초기화한 상태
	}

	int operator[](int n) {
		if ((n < 0) or (num <= n))		// cout으로 부른 값이 num값보다 크거나 같으면, 영보다 작으면
			cout << "범위를 벗어남" << endl;

		return p[n];


	}
};

int main()
{
	SafeIntArray a{ 10 };	// 10개의 정수를 저장할 공간 확보
							// 모든 값을 0으로 

	cout << a[-1] << endl;	// 범위를 벗어남

	cout << a[10] << endl;	// 범위를 벗어남

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-11 오후 1:04:09 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 11일 (10주 2일)

연산자 오버로딩 */
 //-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class SafeIntArray {
	size_t num;
	int* p;

public:
	SafeIntArray(size_t n) : num{ n } {	// num은 size_t라서 n도 size_t로 맞추어준다
		p = new int[num] {};		// 배열 저장. 0으로 초기화한 상태
	}

	int operator[](int n) {
		if ((n < 0) or (num <= n))		// cout으로 부른 값이 num값보다 크거나 같으면, 영보다 작으면
			cout << "범위를 벗어남" << endl;

		return p[n];


	}

	size_t size() const {
		return num;
	}
};

int main()
{
	SafeIntArray a{ 10 };	// 10개의 정수를 저장할 공간 확보
							// 모든 값을 0으로 

	for (int i = 0; i < a.size(); ++i)
		cout << a[i] << endl;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-11 오후 1:14:23 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 11일 (10주 2일)

연산자 오버로딩 */
 //-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class SafeIntArray {
	size_t num;
	int* p;

public:
	SafeIntArray(size_t n) : num{ n } {	// num은 size_t라서 n도 size_t로 맞추어준다
		p = new int[num] {};		// 배열 저장. 0으로 초기화한 상태
	}

	int& operator[](int n) {			// 쓰기용도라서 레퍼런스 붙임
		if ((n < 0) or (num <= n))		// cout으로 부른 값이 num값보다 크거나 같으면, 영보다 작으면
			cout << "범위를 벗어남" << endl;

		return p[n];
	}

	int operator[](int n) const {		// 읽기용도라서 레퍼런스 뗌, 읽기 용도는 const 붙임. operator는 읽기/쓰기 둘 다 만들어야함
		if ((n < 0) or (num <= n))		// cout으로 부른 값이 num값보다 크거나 같으면, 영보다 작으면
			cout << "범위를 벗어남" << endl;

		return p[n];
	}

	size_t size() const {
		return num;
	}
};

int main()
{
	SafeIntArray a{ 10 };	// 10개의 정수를 저장할 공간 확보
							// 모든 값을 0으로 

	for (int i = 0; i < a.size(); ++i)
		a[i] = i;

	for (int i = 0; i < a.size(); ++i)
		cout << a[i] << endl;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-11 오후 1:18:55 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 11일 (10주 2일)

연산자 오버로딩 */
 //-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class SafeIntArray {
	size_t num;
	int* p;

public:
	SafeIntArray(size_t n) : num{ n } {	// num은 size_t라서 n도 size_t로 맞추어준다
		p = new int[num] {};		// 배열 저장. 0으로 초기화한 상태
	}

	int& operator[](int n) {			// 쓰기용도라서 레퍼런스 붙임
		if ((n < 0) or (num <= n))		// cout으로 부른 값이 num값보다 크거나 같으면, 영보다 작으면
			cout << "범위를 벗어남" << endl;

		return p[n];
	}

	int operator[](int n) const {		// 읽기용도라서 레퍼런스 뗌, 읽기 용도는 const 붙임. operator는 읽기/쓰기 둘 다 만들어야함
		if ((n < 0) or (num <= n))		// cout으로 부른 값이 num값보다 크거나 같으면, 영보다 작으면
			cout << "범위를 벗어남" << endl;

		return p[n];
	}

	size_t size() const {
		return num;
	}

	friend ostream& operator << (ostream& os, const SafeIntArray&);
};

ostream& operator << (ostream& os, const SafeIntArray& sia)
{
	for (int i = 0; i < sia.num; ++i)
		cout << sia.p[i] << ' ';

	return os;
};

int main()
{
	SafeIntArray a{ 100 };	// 10개의 정수를 저장할 공간 확보
							// 모든 값을 0으로 

	for (int i = 0; i < a.size(); ++i)
		a[i] = i * i;

	cout << a << endl;		// a의 모든 값을 화면에 출력, ostream.

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-11 오후 1:20:21 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 11일 (10주 2일)

연산자 오버로딩 */
 //-------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

class SafeIntArray {
	size_t num;
	int* p;

public:
	SafeIntArray(size_t n) : num{ n } {	// num은 size_t라서 n도 size_t로 맞추어준다
		p = new int[num] {};		// 배열 저장. 0으로 초기화한 상태
	}

	int& operator[](int n) {			// 쓰기용도라서 레퍼런스 붙임
		if ((n < 0) or (num <= n))		// cout으로 부른 값이 num값보다 크거나 같으면, 영보다 작으면
			cout << "범위를 벗어남" << endl;

		return p[n];
	}

	int operator[](int n) const {		// 읽기용도라서 레퍼런스 뗌, 읽기 용도는 const 붙임. operator는 읽기/쓰기 둘 다 만들어야함
		if ((n < 0) or (num <= n))		// cout으로 부른 값이 num값보다 크거나 같으면, 영보다 작으면
			cout << "범위를 벗어남" << endl;

		return p[n];
	}

	size_t size() const {
		return num;
	}

	friend ostream& operator << (ostream& os, const SafeIntArray&);
};

ostream& operator << (ostream& os, const SafeIntArray& sia)
{
	for (int i = 0; i < sia.num; ++i)
		cout << sia.p[i] << ' ';

	return os;
};

int main()
{
	SafeIntArray a{ 100 };	// 10개의 정수를 저장할 공간 확보
							// 모든 값을 0으로 

	for (int i = 0; i < a.size(); ++i)
		a[i] = i * i;

	ofstream out("안전배열100개");
	out << a << endl;		// a의 모든 값을 화면에 출력, ostream.

	// in >> a;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-16 오후 1:36:50 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 16일 (11주 1일)

연산자 오버로딩 */
 //-------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

class SafeIntArray {
	size_t num;
	int* p;

public:
	SafeIntArray(size_t n) : num{ n } {	// num은 size_t라서 n도 size_t로 맞추어준다
		p = new int[num] {};			// 배열 저장. 0으로 초기화한 상태
	}

	int& operator[](int n) {			// 쓰기용도라서 레퍼런스 붙임
		if ((n < 0) or (num <= n))		// cout으로 부른 값이 num값보다 크거나 같으면, 영보다 작으면
			cout << "범위를 벗어남" << endl;

		return p[n];
	}

	int operator[](int n) const {		// 읽기용도라서 레퍼런스 뗌, 읽기 용도는 const 붙임. operator는 읽기/쓰기 둘 다 만들어야함
		if ((n < 0) or (num <= n))		// cout으로 부른 값이 num값보다 크거나 같으면, 영보다 작으면
			cout << "범위를 벗어남" << endl;

		return p[n];
	}

	size_t size() const {
		return num;
	}

	friend ostream& operator << (ostream& os, const SafeIntArray&);
};

ostream& operator << (ostream& os, const SafeIntArray& sia)
{
	for (int i = 0; i < sia.num; ++i)
		cout << sia.p[i] << ' ';

	return os;
};

// [문제] 파일 "안전배열100개"에 SafeIntArray 객체 100개가 저장되어 있다.
// 객체를 읽어 객체의 배열에 저장하시오

int main()
{
	// 파일을 연다
	ifstream in("안전배열100개");	// 없는 파일임

	if (!in) {
		cout << "파일을 열지 못함" << endl;
		return 1234;
	}

	// 한 번에 하나씩 읽어온다

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-16 오후 1:52:41 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 16일 (11주 1일)

연산자 오버로딩 */
 //-------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

class SafeIntArray {
	size_t num;
	int* p;

public:
	SafeIntArray() { 
		num = 0;
		p = nullptr;
	}

	SafeIntArray(size_t n) : num{ n } {	// num은 size_t라서 n도 size_t로 맞추어준다
		p = new int[num] {};			// 배열 저장. 0으로 초기화한 상태
	}

	int& operator[](int n) {			// 쓰기용도라서 레퍼런스 붙임
		if ((n < 0) or (num <= n))		// cout으로 부른 값이 num값보다 크거나 같으면, 영보다 작으면
			cout << "범위를 벗어남" << endl;

		return p[n];
	}

	int operator[](int n) const {		// 읽기용도라서 레퍼런스 뗌, 읽기 용도는 const 붙임. operator는 읽기/쓰기 둘 다 만들어야함
		if ((n < 0) or (num <= n))		// cout으로 부른 값이 num값보다 크거나 같으면, 영보다 작으면
			cout << "범위를 벗어남" << endl;

		return p[n];
	}

	size_t size() const {
		return num;
	}

	void setNum(int n) {
		delete[] p;
		num = n;
		p = new int[num];
	}

	friend ostream& operator << (ostream& os, const SafeIntArray&);
	friend istream& operator >> (istream& is, SafeIntArray&); // 읽어와야되기 때문에 const 안씀
};

ostream& operator << (ostream& os, const SafeIntArray& sia)
{
	for (int i = 0; i < sia.num; ++i)
		cout << sia.p[i] << ' ';

	return os;
};

istream& operator >> (istream& is, SafeIntArray& sia) {
	for (int i = 0; i < sia.num; ++i) {
		int num;
		is >> num;
		cout << num << " -- ";
		sia.p[i] = num;
	}
	return is;
}

// [문제] 파일 "안전배열100개"에 SafeIntArray 객체 한 개가 저장되어 있다.
// (정수 100개로 된 안전배열이다.)
// 객체를 읽어 객체의 배열에 저장하시오.

int main()
{
	// 파일을 연다
	ifstream in("안전배열100개");	// 없는 파일임

	if (!in) {
		cout << "파일을 열지 못함" << endl;
		return 1234;
	}

	// 한 번에 하나씩 읽어온다
	SafeIntArray sia;			// [갯수][ p ] --> [0][1][4][9][][][]…
								// [100][ p ]

	sia.setNum(100);

	in >> sia;					// 객체 하나라 한번만 가져오면 됨

	cout << sia;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-16 오후 1:53:38 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 16일 (11주 1일)

연산자 오버로딩 */
 //-------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

class SafeIntArray {
	size_t num;
	int* p;

public:
	SafeIntArray(size_t n) : num{ n } {	// num은 size_t라서 n도 size_t로 맞추어준다
		p = new int[num] {};		// 배열 저장. 0으로 초기화한 상태
	}

	int& operator[](int n) {			// 쓰기용도라서 레퍼런스 붙임
		if ((n < 0) or (num <= n))		// cout으로 부른 값이 num값보다 크거나 같으면, 영보다 작으면
			cout << "범위를 벗어남" << endl;

		return p[n];
	}

	int operator[](int n) const {		// 읽기용도라서 레퍼런스 뗌, 읽기 용도는 const 붙임. operator는 읽기/쓰기 둘 다 만들어야함
		if ((n < 0) or (num <= n))		// cout으로 부른 값이 num값보다 크거나 같으면, 영보다 작으면
			cout << "범위를 벗어남" << endl;

		return p[n];
	}

	size_t size() const {
		return num;
	}

	friend ostream& operator << (ostream& os, const SafeIntArray&);
};

ostream& operator << (ostream& os, const SafeIntArray& sia)
{
	for (int i = 0; i < sia.num; ++i)
		cout << sia.p[i] << ' ';

	return os;
};

int main()
{
	SafeIntArray a{ 100 };	// 10개의 정수를 저장할 공간 확보
							// 모든 값을 0으로 

	for (int i = 0; i < a.size(); ++i)
		a[i] = i * i;

	ofstream out("안전배열100개");
	out << a << endl;		// a의 모든 값을 화면에 출력, ostream.

	// in >> a;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-16 오후 1:53:47 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 16일 (11주 1일)

연산자 오버로딩 */
 //-------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

class SafeIntArray {
	size_t num;
	int* p;

public:
	SafeIntArray() { 
		num = 0;
		p = nullptr;
	}

	SafeIntArray(size_t n) : num{ n } {	// num은 size_t라서 n도 size_t로 맞추어준다
		p = new int[num] {};			// 배열 저장. 0으로 초기화한 상태
	}

	int& operator[](int n) {			// 쓰기용도라서 레퍼런스 붙임
		if ((n < 0) or (num <= n))		// cout으로 부른 값이 num값보다 크거나 같으면, 영보다 작으면
			cout << "범위를 벗어남" << endl;

		return p[n];
	}

	int operator[](int n) const {		// 읽기용도라서 레퍼런스 뗌, 읽기 용도는 const 붙임. operator는 읽기/쓰기 둘 다 만들어야함
		if ((n < 0) or (num <= n))		// cout으로 부른 값이 num값보다 크거나 같으면, 영보다 작으면
			cout << "범위를 벗어남" << endl;

		return p[n];
	}

	size_t size() const {
		return num;
	}

	void setNum(int n) {
		delete[] p;
		num = n;
		p = new int[num];
	}

	friend ostream& operator << (ostream& os, const SafeIntArray&);
	friend istream& operator >> (istream& is, SafeIntArray&); // 읽어와야되기 때문에 const 안씀
};

ostream& operator << (ostream& os, const SafeIntArray& sia)
{
	for (int i = 0; i < sia.num; ++i)
		cout << sia.p[i] << ' ';

	return os;
};

istream& operator >> (istream& is, SafeIntArray& sia) {
	for (int i = 0; i < sia.num; ++i) {
		int num;
		is >> num;
		cout << num << " -- ";
		sia.p[i] = num;
	}
	return is;
}

// [문제] 파일 "안전배열100개"에 SafeIntArray 객체 한 개가 저장되어 있다.
// (정수 100개로 된 안전배열이다.)
// 객체를 읽어 객체의 배열에 저장하시오.

int main()
{
	// 파일을 연다
	ifstream in("안전배열100개");	// 없는 파일임

	if (!in) {
		cout << "파일을 열지 못함" << endl;
		return 1234;
	}

	// 한 번에 하나씩 읽어온다
	SafeIntArray sia;			// [갯수][ p ] --> [0][1][4][9][][][]…
								// [100][ p ]

	sia.setNum(100);

	in >> sia;					// 객체 하나라 한번만 가져오면 됨

	cout << sia;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-16 오후 2:15:42 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 16일 (11주 1일)

연산자 오버로딩 */
 //-------------------------------------------------------------------------
#include <iostream>

#include "save.h"
using namespace std;

class String {
	size_t num;
	char* p;

public:
	String(const char* s) {
		num = strlen(s);
		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = s[i];			// 인자로 넘어온 s로 p를 채움
	}

	~String() {

	}
};

int main()
{
	String a{ "12345" };			// [5][ p ] --> [1][2][3][4][5]
	String b{ "67890abcde" };		// [10][ p ] --> [6][7][8][9][0][a][b][c][d][e]

//	String c = a + b;				// [15][ p ] --> [1][2][3][4][5][6][7]...

//	cout << c << endl;				// 123456789abcde

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-16 오후 2:28:38 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 16일 (11주 1일)

연산자 오버로딩 */
 //-------------------------------------------------------------------------
#include <iostream>

#include "save.h"
using namespace std;

class String {
	size_t num;
	char* p;

public:
	String() {
		num = 0;
		p = nullptr;
	}

	String(const char* s) {
		num = strlen(s);
		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = s[i];			// 인자로 넘어온 s로 p를 채움
	}

	~String() {
		delete[] p;
	}

	String(const String& other) {
		num = other.num;
		p = new char[num];
		for (int i = 0; i < num; ++i)
			p[i] = other.p[i];
	}

	String operator+(const String& rhs) const {
		String temp;
		temp.num = num + rhs.num;
		temp.p = new char[temp.num];

		for (int i = 0; i < num; ++i)
			temp.p[i] = p[i];

		for (int i = 0; i < rhs.num; ++i)
			temp.p[num + i] = rhs.p[i];

		return temp;
	}

	friend ostream& operator<<(ostream&, const String&);
};

ostream& operator<<(ostream& os, const String& s)
{
	for (int i = 0; i < s.num; ++i)
		os << s.p[i];

	return os;
}

int main()
{
	String a{ "12345" };			// [5][ p ] --> [1][2][3][4][5]
	String b{ "67890abcde"};		// [10][ p ] --> [6][7][8][9][0][a][b][c][d][e]

	String c = a + b;				// [15][ p ] --> [1][2][3][4][5][6][7]...
	// String c { String a.operator+(b) }	// a와 b를 합침.


	cout << c << endl;				// 123456789abcde

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-16 오후 2:49:31 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 16일 (11주 1일)

연산자 오버로딩 */
 //-------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <random>
#include <string>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution <> uid_len{ 5, 30 };
uniform_int_distribution <> uid_char{ 'a','z' };
uniform_int_distribution <> uid;

class Dog {
	string name;		// 이름: 길이 [5, 30], 문자 ['a', 'z'] 랜덤엔진으로 만들기
	int id;				// 그냥 랜덤 정수

public:
	Dog() {
		for ( int i = 0 ; i < uid_len(dre); ++i)
			name += uid_char(dre);
		id = uid(dre);
	}

	void show() const {
		cout << id << " - " << name << endl;
	}
};

// [문제] Dog 객체 10000개를 파일 "Dog만객체"에 저장하라.
// 디폴트 생성하면 멤버변수 주석에 적은 것과 같이 생성

int main()
{
	Dog dog;
	dog.show();

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-16 오후 3:02:39 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 16일 (11주 1일)

연산자 오버로딩 */
 //-------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <random>
#include <string>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution <> uid_len{ 5, 30 };
uniform_int_distribution <> uid_char{ 'a','z' };
uniform_int_distribution <> uid;

class Dog {
	string name;		// 이름: 길이 [5, 30], 문자 ['a', 'z'] 랜덤엔진으로 만들기
	int id;				// 그냥 랜덤 정수

public:
	Dog() {
		for ( int i = 0 ; i < uid_len(dre); ++i)
			name += uid_char(dre);
		id = uid(dre);
	}

	void show() const {
		cout << id << " - " << name << endl;
	}

	void getNum() {

	}

	friend ostream& operator<<(ostream& os, const Dog& dog);
};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << " " << dog.id;
	return os;;
}

// [문제] Dog 객체 10000개를 파일 "Dog만객체"에 저장하라.
// 디폴트 생성하면 멤버변수 주석에 적은 것과 같이 생성

int main()
{
	Dog dog;
	dog.show();

	// 파일에 기록할때는
	// out << dog를 이용할 수 있어야 한다

	cout << dog;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-16 오후 3:05:37 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 16일 (11주 1일)

연산자 오버로딩 */
 //-------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <random>
#include <string>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution <> uid_len{ 5, 30 };
uniform_int_distribution <> uid_char{ 'a','z' };
uniform_int_distribution <> uid;

class Dog {
	string name;		// 이름: 길이 [5, 30], 문자 ['a', 'z'] 랜덤엔진으로 만들기
	int id;				// 그냥 랜덤 정수

public:
	Dog() {
		for ( int i = 0 ; i < uid_len(dre); ++i)
			name += uid_char(dre);
		id = uid(dre);
	}

	void show() const {
		cout << id << " - " << name << endl;
	}

	void getNum() {

	}

	friend ostream& operator<<(ostream& os, const Dog& dog);
};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << " " << dog.id;
	return os;;
}

// [문제] Dog 객체 10000개를 파일 "Dog만객체"에 저장하라.
// 디폴트 생성하면 멤버변수 주석에 적은 것과 같이 생성

int main()
{
	ofstream out("Dog만객체");
	
	for (int i = 0; i < 10'000; ++i) {
		Dog dog;
		out << dog << endl;
	}

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-18 오전 11:41:03 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 16일 (11주 1일)

연산자 오버로딩 */
 //-------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <random>
#include <string>
#include <algorithm>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution <> uid_len{ 5, 30 };
uniform_int_distribution <> uid_char{ 'a','z' };
uniform_int_distribution <> uid;

class Dog {
	string name;		// 이름: 길이 [5, 30], 문자 ['a', 'z'] 랜덤엔진으로 만들기
	int id;				// 그냥 랜덤 정수

public:
	Dog() {
		int num = uid_len(dre);			// loop inveriant
		for ( int i = 0 ; i < num; ++i)
			name += uid_char(dre);
		id = uid(dre);
	}

	void show() const {
		cout << id << " - " << name << endl;
	}

	friend ostream& operator<<(ostream& os, const Dog& dog);
	friend istream& operator>>(istream& is, Dog& dog);
};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << " " << dog.id;
	return os;;
}

istream& operator>>(istream& is, Dog& dog)
{
	
}

// [문제] "Dog만객체" 파일에 있는 Dog 객체 10000개를 읽어와라.
// id 오름차순 정렬한 후 전체를 show() 출력하라.

// 위의 문제와는 별개로 해결해보자. (파일에서 읽어서 해결 시작)
// (도전) 이름의 길이가 15인 Dog를 골라 "이름길이가30인Dog"에 저장하라.

int main()
{
	ifstream in("Dog만객체");
	
	if (!in) {				// input 파일이 잘못됐을 경우
		cout << "파일열기 실패" << endl;
		exit( 12345 );		// 프로그램 탈출
	}

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-18 오전 11:47:47 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 16일 (11주 1일)

연산자 오버로딩 */
 //-------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <random>
#include <string>
#include <algorithm>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution <> uid_len{ 5, 30 };
uniform_int_distribution <> uid_char{ 'a','z' };
uniform_int_distribution <> uid;

class Dog {
	string name;		// 이름: 길이 [5, 30], 문자 ['a', 'z'] 랜덤엔진으로 만들기
	int id;				// 그냥 랜덤 정수

public:
	Dog() {
		int num = uid_len(dre);			// loop inveriant
		for ( int i = 0 ; i < num; ++i)
			name += uid_char(dre);
		id = uid(dre);
	}

	void show() const {
		cout << id << " - " << name << endl;
	}

	friend ostream& operator<<(ostream& os, const Dog& dog);
	friend istream& operator>>(istream& is, Dog& dog);		// 기록 가능하도록 const 떼어야 됨
};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << " " << dog.id;
	return os;;
}

istream& operator>>(istream& is, Dog& dog)
{
	is >> dog.name >> dog.id;
	return is;
}

// [문제] "Dog만객체" 파일에 있는 Dog 객체 10000개를 읽어와라.
// id 오름차순 정렬한 후 전체를 show() 출력하라.

// 위의 문제와는 별개로 해결해보자. (파일에서 읽어서 해결 시작)
// (도전) 이름의 길이가 15인 Dog를 골라 "이름길이가30인Dog"에 저장하라.

int main()
{
	ifstream in("Dog만객체");
	
	Dog dog;

	for (int i = 0; i < 10; ++i) {	// 10개만 불러옴
		in >> dog;
		cout << dog << endl;
	}

	for (int i = 0; i > 10000 - 20; ++i)	// 끝에서부터 20번째
		in >> dog;
	cout << endl << endl;

	//while (in >> dog) {		// dog 끝까지 읽어옴
	//	cout << dog << endl;
	//};

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-18 오전 11:51:24 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 16일 (11주 1일)

연산자 오버로딩 */
 //-------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <random>
#include <string>
#include <algorithm>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution <> uid_len{ 5, 30 };
uniform_int_distribution <> uid_char{ 'a','z' };
uniform_int_distribution <> uid;

class Dog {
	string name;		// 이름: 길이 [5, 30], 문자 ['a', 'z'] 랜덤엔진으로 만들기
	int id;				// 그냥 랜덤 정수

public:
	Dog() {
		int num = uid_len(dre);			// loop inveriant
		for ( int i = 0 ; i < num; ++i)
			name += uid_char(dre);
		id = uid(dre);
	}

	void show() const {
		cout << id << " - " << name << endl;
	}

	friend ostream& operator<<(ostream& os, const Dog& dog);
	friend istream& operator>>(istream& is, Dog& dog);		// 기록 가능하도록 const 떼어야 됨
};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << " " << dog.id;
	return os;;
}

istream& operator>>(istream& is, Dog& dog)
{
	is >> dog.name >> dog.id;
	return is;
}

// [문제] "Dog만객체" 파일에 있는 Dog 객체 10000개를 읽어와라.
// id 오름차순 정렬한 후 전체를 show() 출력하라.

// 위의 문제와는 별개로 해결해보자. (파일에서 읽어서 해결 시작)
// (도전) 이름의 길이가 15인 Dog를 골라 "이름길이가30인Dog"에 저장하라.

int main()
{
	ifstream in("Dog만객체");
	
	Dog* dogs = new Dog[10'000];		// 정렬하기 위해 메모리 공간 필요

	int i = 0;
	while (in >> dogs[i]) {
		++i;
	}

	cout << dogs[0] << endl;	// 첫번째 값확인
	cout << dogs[9999] << endl;	// 마지막값 확인 

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-18 오후 12:07:16 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 16일 (11주 1일)

연산자 오버로딩 */
 //-------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <random>
#include <string>
#include <algorithm>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution <> uid_len{ 5, 30 };
uniform_int_distribution <> uid_char{ 'a','z' };
uniform_int_distribution <> uid;

class Dog {
	string name;		// 이름: 길이 [5, 30], 문자 ['a', 'z'] 랜덤엔진으로 만들기
	int id;				// 그냥 랜덤 정수

public:
	Dog() {
		int num = uid_len(dre);			// loop inveriant
		for ( int i = 0 ; i < num; ++i)
			name += uid_char(dre);
		id = uid(dre);
	}

	void show() const {
		cout << id << " - " << name << endl;
	}

	int getID() const {		// ID를 반환하니까 int. 값 변경 없으니 const.
		return id;
	}

	string_view getName() const {	// 기능은 똑같이 쓰면서 포인터를 리턴하는 것. 더 빠름.
		return name;
	}

	friend ostream& operator<<(ostream& os, const Dog& dog);
	friend istream& operator>>(istream& is, Dog& dog);		// 기록 가능하도록 const 떼어야 됨
};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << " " << dog.id;
	return os;;
}

istream& operator>>(istream& is, Dog& dog)
{
	is >> dog.name >> dog.id;
	return is;
}

// [문제] "Dog만객체" 파일에 있는 Dog 객체 10000개를 읽어와라.
// 이름 길이 오름차순 정렬한 후 전체를 show() 출력하라.

// 위의 문제와는 별개로 해결해보자. (파일에서 읽어서 해결 시작)
// (도전) 이름의 길이가 15인 Dog를 골라 "이름길이가30인Dog"에 저장하라.

int main()
{
	ifstream in("Dog만객체");
	
	Dog* dogs = new Dog[10'000];		// 정렬하기 위해 메모리 공간 필요 *중요한 부분*

	cout << "읽는 중" << endl;
	int i = 0;							// 10000개를 읽어오는 코딩 *중요*
	while (in >> dogs[i]) {
		++i;
	}

	cout << "정렬 중" << endl;
	sort(&dogs[0], &dogs[10000], [](const Dog& a, const Dog& b) { // sort( begin, end )는 붙어있는 값을 정렬함. 비교만 할 거기 때문에 const Dog&
		return a.getName().size() < b.getName().size();			  // 길이 비교하기 때문에 .size
		});
										 // dogs[9999]가 존재하는 마지막값이지만 C++ 약속으로 dogs[10000]이라고 씀
	cout << "정렬이 끝났습니다. 키를 누르세요" << endl;
	char ch;
	cin >> ch;

	for (int i = 0; i < 10'000 ; ++i)
		cout << dogs[i] << endl;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-18 오후 12:11:45 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 16일 (11주 1일)

연산자 오버로딩 */
 //-------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <random>
#include <string>
#include <algorithm>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution <> uid_len{ 5, 30 };
uniform_int_distribution <> uid_char{ 'a','z' };
uniform_int_distribution <> uid;

class Dog {
	string name;		// 이름: 길이 [5, 30], 문자 ['a', 'z'] 랜덤엔진으로 만들기
	int id;				// 그냥 랜덤 정수

public:
	Dog() {
		int num = uid_len(dre);			// loop inveriant
		for ( int i = 0 ; i < num; ++i)
			name += uid_char(dre);
		id = uid(dre);
	}

	void show() const {
		cout << id << " - " << name << endl;
	}

	int getID() const {		// ID를 반환하니까 int. 값 변경 없으니 const.
		return id;
	}

	string_view getName() const {	// 기능은 똑같이 쓰면서 포인터를 리턴하는 것. 더 빠름.
		return name;
	}

	friend ostream& operator<<(ostream& os, const Dog& dog);
	friend istream& operator>>(istream& is, Dog& dog);		// 기록 가능하도록 const 떼어야 됨
};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << " " << dog.id;
	return os;;
}

istream& operator>>(istream& is, Dog& dog)
{
	string name;
	is >> name;
	sort(begin(name), end(name));		// abc 순서대로 정렬할 수 있음

	dog.name = name;
	is >> dog.id;
	return is;
}

// [문제] "Dog만객체" 파일에 있는 Dog 객체 10000개를 읽어와라.
// 이름 길이 오름차순 정렬한 후 전체를 show() 출력하라.

// 위의 문제와는 별개로 해결해보자. (파일에서 읽어서 해결 시작)
// (도전) 이름의 길이가 15인 Dog를 골라 "이름길이가30인Dog"에 저장하라.

int main()
{
	ifstream in("Dog만객체");
	
	Dog* dogs = new Dog[10'000];		// 정렬하기 위해 메모리 공간 필요 *중요한 부분*

	cout << "읽는 중" << endl;
	int i = 0;							// 10000개를 읽어오는 코딩 *중요*
	while (in >> dogs[i])
		++i;

	cout << "정렬 중" << endl;
	sort(&dogs[0], &dogs[10000], [](const Dog& a, const Dog& b) { // sort( begin, end )는 붙어있는 값을 정렬함. 비교만 할 거기 때문에 const Dog&
		return a.getName().size() < b.getName().size();			  // 길이 비교하기 때문에 .size
		});
										 // dogs[9999]가 존재하는 마지막값이지만 C++ 약속으로 dogs[10000]이라고 씀
	cout << "정렬이 끝났습니다. 키를 누르세요" << endl;
	char ch;
	cin >> ch;

	for (int i = 0; i < 10'000 ; ++i)
		cout << dogs[i] << endl;

	save("소스.cpp");
}	// 이름을 abc 순서대로 정렬 가능해짐




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-18 오후 12:13:46 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 16일 (11주 1일)

연산자 오버로딩 */
 //-------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <random>
#include <string>
#include <algorithm>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution <> uid_len{ 5, 30 };
uniform_int_distribution <> uid_char{ 'a','z' };
uniform_int_distribution <> uid;

class Dog {
	string name;		// 이름: 길이 [5, 30], 문자 ['a', 'z'] 랜덤엔진으로 만들기
	int id;				// 그냥 랜덤 정수

public:
	Dog() {
		int num = uid_len(dre);			// loop inveriant
		for ( int i = 0 ; i < num; ++i)
			name += uid_char(dre);
		id = uid(dre);
	}

	void show() const {
		cout << id << " - " << name << endl;
	}

	int getID() const {		// ID를 반환하니까 int. 값 변경 없으니 const.
		return id;
	}

	string_view getName() const {	// 기능은 똑같이 쓰면서 포인터를 리턴하는 것. 더 빠름.
		return name;
	}

	friend ostream& operator<<(ostream& os, const Dog& dog);
	friend istream& operator>>(istream& is, Dog& dog);		// 기록 가능하도록 const 떼어야 됨
};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << " " << dog.id;
	return os;;
}

istream& operator>>(istream& is, Dog& dog)
{
	string name;
	is >> name;
	sort(begin(name), end(name));		// abc 순서대로 정렬할 수 있음

	dog.name = name;
	is >> dog.id;
	return is;
}

// [문제] "Dog만객체" 파일에 있는 Dog 객체 10000개를 읽어와라.
// 이름 길이 오름차순 정렬한 후 전체를 show() 출력하라.

// 위의 문제와는 별개로 해결해보자. (파일에서 읽어서 해결 시작)
// (도전) 이름의 길이가 30인 Dog를 골라 "이름길이가30인Dog"에 저장하라.

int main()
{
	ifstream in("Dog만객체");
	
	Dog dog;

	while (in >> dog) {					// 이름길이 30자인 것만 찾아오는 코드
		if (dog.getName().size() == 30)	// getName().size()로 30인 것들 가져오기
			cout << dog;
	}

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-18 오후 12:14:29 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 16일 (11주 1일)

연산자 오버로딩 */
 //-------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <random>
#include <string>
#include <algorithm>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution <> uid_len{ 5, 30 };
uniform_int_distribution <> uid_char{ 'a','z' };
uniform_int_distribution <> uid;

class Dog {
	string name;		// 이름: 길이 [5, 30], 문자 ['a', 'z'] 랜덤엔진으로 만들기
	int id;				// 그냥 랜덤 정수

public:
	Dog() {
		int num = uid_len(dre);			// loop inveriant
		for ( int i = 0 ; i < num; ++i)
			name += uid_char(dre);
		id = uid(dre);
	}

	void show() const {
		cout << id << " - " << name << endl;
	}

	int getID() const {		// ID를 반환하니까 int. 값 변경 없으니 const.
		return id;
	}

	string_view getName() const {	// 기능은 똑같이 쓰면서 포인터를 리턴하는 것. 더 빠름.
		return name;
	}

	friend ostream& operator<<(ostream& os, const Dog& dog);
	friend istream& operator>>(istream& is, Dog& dog);		// 기록 가능하도록 const 떼어야 됨
};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << " " << dog.id;
	return os;;
}

istream& operator>>(istream& is, Dog& dog)
{
	string name;
	is >> name;
	sort(begin(name), end(name));		// abc 순서대로 정렬할 수 있음

	dog.name = name;
	is >> dog.id;
	return is;
}

// [문제] "Dog만객체" 파일에 있는 Dog 객체 10000개를 읽어와라.
// 이름 길이 오름차순 정렬한 후 전체를 show() 출력하라.

// 위의 문제와는 별개로 해결해보자. (파일에서 읽어서 해결 시작)
// (도전) 이름의 길이가 15인 Dog를 골라 "이름길이가30인Dog"에 저장하라.

int main()
{
	ifstream in("Dog만객체");
	
	Dog dog;

	while (in >> dog) {					// 이름길이 15자인 것만 찾아오는 코드
		if (dog.getName().size() == 15)	// getName().size()로 30인 것들 가져오기
			cout << dog;
	}

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-18 오후 12:15:59 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 16일 (11주 1일)

연산자 오버로딩 */
 //-------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <random>
#include <string>
#include <algorithm>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution <> uid_len{ 5, 30 };
uniform_int_distribution <> uid_char{ 'a','z' };
uniform_int_distribution <> uid;

class Dog {
	string name;		// 이름: 길이 [5, 30], 문자 ['a', 'z'] 랜덤엔진으로 만들기
	int id;				// 그냥 랜덤 정수

public:
	Dog() {
		int num = uid_len(dre);			// loop inveriant
		for ( int i = 0 ; i < num; ++i)
			name += uid_char(dre);
		id = uid(dre);
	}

	void show() const {
		cout << id << " - " << name << endl;
	}

	int getID() const {		// ID를 반환하니까 int. 값 변경 없으니 const.
		return id;
	}

	string_view getName() const {	// 기능은 똑같이 쓰면서 포인터를 리턴하는 것. 더 빠름.
		return name;
	}

	friend ostream& operator<<(ostream& os, const Dog& dog);
	friend istream& operator>>(istream& is, Dog& dog);		// 기록 가능하도록 const 떼어야 됨
};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << " " << dog.id;
	return os;;
}

istream& operator>>(istream& is, Dog& dog)
{
	string name;
	is >> name;
	sort(begin(name), end(name));		// abc 순서대로 정렬할 수 있음

	dog.name = name;
	is >> dog.id;
	return is;
}

// [문제] "Dog만객체" 파일에 있는 Dog 객체 10000개를 읽어와라.
// 이름 길이 오름차순 정렬한 후 전체를 show() 출력하라.

// 위의 문제와는 별개로 해결해보자. (파일에서 읽어서 해결 시작)
// (도전) 이름의 길이가 15인 Dog를 골라 "이름길이가15인Dog"에 저장하라.

int main()
{
	ifstream in("Dog만객체");
	
	Dog dog;

	ofstream out("이름길이가15인Dog");

	while (in >> dog) {					// 이름길이 15자인 것만 찾아오는 코드
		if (dog.getName().size() == 15)	// getName().size()로 30인 것들 가져오기
			out << dog << endl;
	}

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-18 오후 12:45:41 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 18일 (11주 2일)

클래스 간의 관계 - 상속(P.286) */
 //-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class A{};

class B : A	{		// 상속 : inheritance, 다형성(다양한 형태)

};

int main()
{
	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-18 오후 12:58:06 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 18일 (11주 2일)

클래스 간의 관계 - 상속(P.286) */
 //-------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class String : public string {		// 이미 string에 있는 기능을 이용하기 위해 상속받음

public:
	String(const char* s) : string { s } {
		*(this->begin()) = toupper(*(this->begin()));
	}
};

// [문제] 소문자를 입력하면 자동으로 대문자로 바꿔 저장하는 스트링 클래스가 필요하다

int main()
{
	String a{ "abced" };
	String b{ "fghijklmnopqrstuvwxyz" };
//	String c = a + b;

	cout << a << endl;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-18 오후 12:59:23 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 18일 (11주 2일)

클래스 간의 관계 - 상속(P.286) */
 //-------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class String : public string {		// 이미 string에 있는 기능을 이용하기 위해 상속받음

public:
	String(const char* s) : string { s } {
		for (auto i = this->begin(); i != this->end(); ++i)
			*i = toupper(*i);
	}
};

// [문제] 소문자를 입력하면 자동으로 대문자로 바꿔 저장하는 스트링 클래스가 필요하다

int main()
{
	String a{ "abced" };
	String b{ "fghijklmnopqrstuvwxyz" };
//	String c = a + b;

	cout << a << endl;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-18 오후 1:02:27 - (수요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 18일 (11주 2일)

클래스 간의 관계 - 상속(P.286) */
 //-------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class String : public string {		// 이미 string에 있는 기능을 이용하기 위해 상속받음

public:
	String(const char* s) : string { s } {
		for (auto i = this->begin(); i != this->end(); ++i)
			*i = toupper(*i);
	}
};

// [문제] 소문자를 입력하면 자동으로 대문자로 바꿔 저장하는 스트링 클래스가 필요하다

int main()
{
	String a{ "abced" };
	String b{ "fghijklmnopqrstuvwxyz" };
//	String c = a + b;

	cout << a << endl;
	cout << b << endl;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-23 오후 1:54:50 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 18일 (12주 1일)

클래스 간의 관계 - 상속(P.286)
1. 코드를 재사용
2. 다형성(polymorphism)을 구현

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] 모든 문자를 대문자로 관리하는 string class를 만들고 싶다
// 상속을 이용하면 내가 다 안 만들어도 된다는데...
// 문제없이 main이 실행되게 해 보자. (최소한의 노력을 해서)

class STRING : public string {

public:
	STRING(string s) : string{ s } {
		for (auto i = begin(); i != end(); ++i)
			*i = toupper(*i);
	}
};

int main()
{
	STRING a{ "abc" };
	STRING b{ "-12345" };
	STRING c = a + b;
	
	cout << c << endl;		// abc-12345 가 출력되도록
	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-23 오후 1:56:54 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 23일 (12주 1일)

클래스 간의 관계 - 상속(P.286)
1. 코드를 재사용
2. 다형성(polymorphism)을 구현

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// [문제] 모든 문자를 대문자로 관리하는 string class를 만들고 싶다
// 상속을 이용하면 내가 다 안 만들어도 된다는데...
// 문제없이 main이 실행되게 해 보자. (최소한의 노력을 해서)

class STRING : public string {

public:
	STRING( const char* s) : string{ s } {
		for (auto i = begin(); i != end(); ++i)
			*i = toupper(*i);
	}

	STRING(string s) : string{ s } {

	}
};

int main()
{
	STRING a{ "abc" };
	STRING b{ "-12345" };
	STRING c = a + b;
	
	cout << c << endl;		// abc-12345 가 출력되도록
	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-23 오후 2:00:17 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 23일 (12주 1일)

클래스 간의 관계 - 상속(P.286)
2. 다형성(polymorphism)을 구현

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Parent {
	int p{ };
};

class Child : public Parent {
	int c{};
};

// [문제] 객체의 메모리 크기는 ?

int main()
{
	Parent p;
	Child c;
	cout << sizeof(p) << " " << sizeof(c) << endl;		// '4 8'이 출력됨

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-23 오후 2:02:25 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 23일 (12주 1일)

클래스 간의 관계 - 상속(P.286)
2. 다형성(polymorphism)을 구현

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Parent {
	int p{ };
};

class Child : public Parent {
	int c{};
};

// [문제] 객체의 메모리 크기는 ?

int main()
{
	Child c;

	cout << "자식객체의 메모리 = 자식메모리 + 부모메모리 = " << sizeof(Child) << endl;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-23 오후 2:08:36 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 23일 (12주 1일)

클래스 간의 관계 - 상속(P.286)
2. 다형성(polymorphism)을 구현

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Parent {
	int p{ };

public:
	Parent() {
		cout << "Parent 생성" << endl;
	}

	~Parent() {
		cout << "Parent 소멸" << endl;
	}
};

class Child : public Parent {
	int c{};

public:
	Child() {
		cout << "Child 생성" << endl;
	}

	~Child() {
		cout << "Child 소멸" << endl;
	}
};

// [문제] 만들어진 메모리를 초기화한다.
// 1. 초기화되는 순서와 소멸되는 순서를 관찰한다.

int main()
{
	Child c;

	cout << "자식객체의 메모리 = 자식메모리 + 부모메모리 = " << sizeof(Child) << endl;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-23 오후 2:11:04 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 23일 (12주 1일)

클래스 간의 관계 - 상속(P.286)
2. 다형성(polymorphism)을 구현

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Parent {
	int p{ };

public:
	Parent() {
		cout << "Parent 생성" << endl;
	}

	~Parent() {
		cout << "Parent 소멸" << endl;
	}
};

class Child : public Parent {
	int c{};

public:
	Child() {
		cout << "Child 생성" << endl;
	}

	~Child() {
		cout << "Child 소멸" << endl;
	}
};

// [문제] 만들어진 메모리를 초기화한다.
// 1. 초기화되는 순서와 소멸되는 순서를 관찰한다.

int main()
{
	Child *p = new Child;
	delete p;

	cout << "자식객체의 메모리 = 자식메모리 + 부모메모리 = " << sizeof(Child) << endl;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-23 오후 2:46:30 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 23일 (12주 1일)

클래스 간의 관계 - 상속(P.286)
2. 다형성(polymorphism)을 구현

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;


	
class Parent {
protected:
	int p{ };			// 자식의 private 멤버가 됨

public:
	Parent() = default;
	Parent(int a) : p {a} { }


	int getP() const {
		return p;
	}
};


// Child 메모리크기 >= Parent 메모리크기 


class Child : public Parent {
	int c{};

public:
	Child(int a, int b) : c{ b } {
		p = a;
	}

	friend ostream& operator<<(ostream& os, const Child& c);
};

ostream& operator<<(ostream& os, const Child& c) {
	os << "[" << c.p << "]" << "[" << c.c << "]" << endl;
	return os;
}

// [문제] 만들어진 메모리를 초기화한다.
// 1. 초기화되는 순서와 소멸되는 순서를 관찰한다.

int main()
{
	Child c{ 1, 333 };
	cout << c << endl;		// [1][333]  이렇게 출력되어야 함

	save("소스.cpp");
}




//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 23일 (12주 1일)

클래스 간의 관계 - 상속(P.286)
2. 다형성(polymorphism)을 구현

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Animal {
protected:
	string name;

public:
	void move() const {
		cout << name << "이 움직인다" << endl;
	}
};

class Dog : public Animal {
public:
	Dog(string s) {
		name = s;
	}
};

class Bird : public Animal {
Public:
	Bird (string s) {
		name = s;
	}
};

int main()
{
	Dog dog {"멍"};
	Bird bird {"짹"};

	dog.move();		// "멍이 움직인다"
	bird.move();	// "짹이 움직인다"

	save("소스.cpp");
}




//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 23일 (13주 1일)

클래스 간의 관계 - 상속(P.286)
2. 다형성(polymorphism)을 구현

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

class Animal {		// 추상클래스(abstract) - 객체를 만들 수 없는 클래스이다
					// (Concrete class - 객체를 만들 수 있는 클래스)
					// 인터페이스(move)를 강요하는 클래스이다
protected:
	string name;

public:
	virtual void move() const = 0;	// 순수(=0)가상함수(pure virtual function)
									// pure - 함수의 몸체가 없다 - 강제한다
									// virtual - 자식클래스가 만들길 기대하는 함수
	// 어떤클러스에 소멸자를 코딩해야 하는 경우는?
	//	- 생성하면서 자원을 획득했다면 소멸자에서 반환해야 한다.
	virtual ~Animal() {				// virtual 붙여야 한다. virtual과 짝이 맞아 소멸되게 만들어줌.
		delete[];
	}
};

class Dog : public Animal {
public:
	void move() const override {
		cout << "Dog가 뛴다 - " << endl;
	}

	Dog(string s) {
		name = s;
	}

	
	void move() const noexcept override final {	// 멤버함수 override
		Animal::move();				// name이 움직인다
		cout << name << "이 뛴다" << endl;
	}
};

class Bird : public Animal {
public:
	Bird (string s) {
		name = s;
	}
		
	void move() const noexcept override final {	// 멤버함수 override
		cout << name << "이 난다" << endl;
	}
};

class Bat : public Animal {

};

// [묹[\ 시용자의 입력을 받아 동물들을 관리하는 프로그램
// 1. 몇 마리를 만들지 입력을 받는다
// 2. 랜덤값을 사용하여 홀수면 Dog를 생성, 짝수면 Bird를 생성한다
// 3. 모든 동물에게 move() 명령을 내린다.
// 3.1 동물중에 Dog에게만 move()를 호출하라.
// 4 

default_random_engine dre;

int main()
{
	while (true) {
		int num;
		cout << "몇 마리를 만들까요? " << endl;
		cin >> num;

		Animal** animals = new Animal * [num];


		uniform_int_distribution<> uid{ 0, 1 };

		for (int i = 0; i < num; ++i) {
			// 만일 animals[i]가 원래는 Dog 였다면
			if (dynamic_cast<Dog*>(animals[i]))
				animals[i]->move();
		}

		for (int i = 0; i < num; ++i)
			delete animals[i];

		delete[] animals;
	}
	Dog dog{ "멍" };
	Bird bird {"짹"};

	dog.move();						// "멍이 뛴다"
	bird.move();					// "짹이 난다"

	save("소스.cpp");
} 보수해야 됨




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-30 오후 2:12:08 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 23일 (13주 1일)

클래스 간의 관계 - 상속(P.286)
2. 다형성(polymorphism)을 구현

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class Animal {
public:
	void move() {
		cout << "움직입니다" << endl;
	}
};

int main()
{
	cout << "CODE Segment 코드가 기록되는 메모리 세그먼트" << endl;
	cout << "main 주소 - " << &main << endl;		// main의 번지
	cout << "save 주소 - " << &save << endl;
	cout << "printf 주소 - " << &printf << endl;
	cout << endl;

	auto pmf = &Animal::move;
	void* vp = &pmf;
	cout << "멤버함수의 주소 - " << *(int*)vp << endl;

	int n;
	string s{ "1234123412341234" };

	cout << "STACK의 주소 - " << endl;
	cout << "지역변수 n - " << &n << endl;
	cout << "지역변수 s - " << &s << endl;
	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-11-30 오후 2:13:03 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                    11월 23일 (13주 1일)

클래스 간의 관계 - 상속(P.286)
2. 다형성(polymorphism)을 구현

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class Animal {
public:
	void move() {
		cout << "움직입니다" << endl;
	}
};

int main()
{
	cout << "CODE Segment 코드가 기록되는 메모리 세그먼트" << endl;
	cout << "main 주소 - " << &main << endl;		// main의 번지
	cout << "save 주소 - " << &save << endl;
	cout << "printf 주소 - " << &printf << endl;
	cout << endl;

	auto pmf = &Animal::move;
	void* vp = &pmf;
	cout << "멤버함수의 주소 - " << hex << *(int*)vp << endl;

	cout << endl;

	int n;
	string s{ "1234123412341234" };

	cout << "STACK의 주소 - " << endl;
	cout << "지역변수 n - " << &n << endl;
	cout << "지역변수 s - " << &s << endl;
	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-12-07 오후 1:40:37 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     12월 7일 (14주 1일)

 Templete

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// main을 고치지 말고 의도대로 실행되게 해 보자

void change(int&, int&);

int main()
{
	int a{ 1 }, b{ 2 };

	change(a, b);

	cout << a << ", " << b << endl;

	save("소스.cpp");
}

void change(int& a, int& b) {	// &는 값을 직접 조종하겠다는 뜻
	int temp{ a };
	a = b;
	b = temp;
};




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-12-07 오후 1:45:29 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     12월 7일 (14주 1일)

 Templete

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// main을 고치지 말고 의도대로 실행되게 해 보자

void change(char&, char&);	// 함수 이름은 같은데 인자형태만 다른 걸 오버로딩이라 함
void change(int&, int&);	

int main()
{
	char a{ 1 }, b{ 2 };

	change(a, b);

	cout << a << ", " << b << endl;

	save("소스.cpp");
}

void change(int& a, int& b) {	// &는 값을 직접 조종하겠다는 뜻
	int temp{ a };
	a = b;
	b = temp;
};

void change(char& a, char& b) {	// &는 값을 직접 조종하겠다는 뜻
	char temp{ a };
	a = b;
	b = temp;
};




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-12-07 오후 1:45:45 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     12월 7일 (14주 1일)

 Templete

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// main을 고치지 말고 의도대로 실행되게 해 보자

void change(char&, char&);	// 함수 이름은 같은데 인자형태만 다른 걸 오버로딩이라 함
void change(int&, int&);	

int main()
{
	char a{ '1' }, b{ '2' };

	change(a, b);

	cout << a << ", " << b << endl;

	save("소스.cpp");
}

void change(int& a, int& b) {	// &는 값을 직접 조종하겠다는 뜻
	int temp{ a };
	a = b;
	b = temp;
};

void change(char& a, char& b) {	// &는 값을 직접 조종하겠다는 뜻
	char temp{ a };
	a = b;
	b = temp;
};




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-12-07 오후 2:00:21 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     12월 7일 (14주 1일)

 Templete

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// main을 고치지 말고 의도대로 실행되게 해 보자

class Dog {
	char c;

public:
	Dog(char c) : c{ c } {
	}

	Dog(const Dog& other) = default;

	operator char() {
		return c;
	}
};

void change(char&, char&);	// 함수 이름은 같은데 인자형태만 다른 걸 오버로딩이라 함
void change(int&, int&);	
void change(Dog&, Dog&);


int main()
{
	Dog a{ '1' }, b{ '2' };

	change(a, b);

	cout << a << ", " << b << endl;

	save("소스.cpp");
}


void change(int& a, int& b) {	// &는 값을 직접 조종하겠다는 뜻
	int temp{ a };
	a = b;
	b = temp;
};

void change(char& a, char& b) {	// &는 값을 직접 조종하겠다는 뜻
	char temp{ a };
	a = b;
	b = temp;
};

void change(Dog& a, Dog& b) {
	Dog temp{ a };
	a = b;
	b = temp;
};




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-12-07 오후 2:05:50 - (월요일)
//-------------------------------------------------------------------------

//----------//-------------------------------------------------------------
/* 2020년 2학기 C++                                     12월 7일 (14주 1일)

 Templete

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// main을 고치지 말고 의도대로 실행되게 해 보자

class Dog {
	char c;

public:
	Dog(char c) : c{ c } {
	}

	Dog(const Dog& other) = default;

	friend ostream& operator << (ostream&, const Dog&);
};

void change(char&, char&);	// 함수 이름은 같은데 인자형태만 다른 걸 오버로딩이라 함
void change(int&, int&);	
void change(Dog&, Dog&);


int main()
{
	Dog a{ '1' }, b{ '2' };

	change(a, b);

	cout << a << ", " << b << endl;

	save("소스.cpp");
}


void change(int& a, int& b) 
{	// &는 값을 직접 조종하겠다는 뜻
	int temp{ a };
	a = b;
	b = temp;
};

void change(char& a, char& b) 
{	// &는 값을 직접 조종하겠다는 뜻
	char temp{ a };
	a = b;
	b = temp;
};

void change(Dog& a, Dog& b) 
{
	Dog temp{ a };
	a = b;
	b = temp;
};

ostream& operator << (ostream& os, const Dog& dog)
{
	os << dog.c;
	return os;
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-12-07 오후 2:55:22 - (월요일)
//-------------------------------------------------------------------------

//--------------------------------------------------------------------------
/* 2020년 2학기 C++                                     12월 7일 (14주 1일)

 Template - 왜 만들어진 건가? - 자료형이 무한하다
								오버로딩을 컴퓨터 시켜서 하자
			이걸로 뭘 할 수 있나?
함수, 템플릿

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// [문제] 템플릿 함수를 만든다

template <typename T>
const T& myMax( const T& a, const T& b)	// 읽기용이기 때문에 const
{
	if (a < b)
		return b;

	return a;
}

int main()
{
	cout << myMax( 2, 22324 ) << endl;	// 2
	cout << myMax( string("abc"), string("def") ) << endl;	// def
	save("소스.cpp");
}





//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-12-07 오후 3:02:42 - (월요일)
//-------------------------------------------------------------------------

//--------------------------------------------------------------------------
/* 2020년 2학기 C++                                     12월 7일 (14주 1일)

 Template - 왜 만들어진 건가? - 자료형이 무한하다
								오버로딩을 컴퓨터 시켜서 하자
			이걸로 뭘 할 수 있나?
함수, 템플릿

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] 템플릿 함수를 만든다

template <typename T>
const T& myMax( T a, T b)	// 읽기용이기 때문에 const
{
	if (a < b)
		return b;

	return a;
}

int main()
{
	cout << myMax("1234", "56789") << endl;
	save("소스.cpp");
}





//--------------------------------------------------------------------------
/* 2020년 2학기 C++                                     12월 7일 (14주 1일)

 Template - 왜 만들어진 건가? - 자료형이 무한하다
								오버로딩을 컴퓨터 시켜서 하자
			이걸로 뭘 할 수 있나?
함수, 템플릿

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] 템플릿 함수를 만든다

template <typename T>
const T& myMax( T a, T b)	// 읽기용이기 때문에 const
{
	if (a < b)
		return b;

	return a;
}

// template을 specialization
template <>
const char* myMax(const char* a, const char* b)	// 읽기용이기 때문에 const
{
	if (strlen(a) < strlen(b))
		return b;

	return a;
}

int main()
{
	// 나는 글자수가 많은 것이 크다고 생각해
	cout << myMax<const char*>("1234", "56789") << endl;
	save("소스.cpp");
}




//--------------------------------------------------------------------------
/* 2020년 2학기 C++                                     12월 7일 (14주 1일)

 Template - 왜 만들어진 건가? - 자료형이 무한하다
								오버로딩을 컴퓨터 시켜서 하자
			이걸로 뭘 할 수 있나?
자료형에 무관한 함수를 기술할 수 있다		- 알고리즘
자료형에 무관한 자료구조를 기술할 수 있다	- 자료구조
함수, 템플릿

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std;

class Dog {
	int a;
	string name;
};

// 다형성 - virtual
// template
// template은 generic programming을 구현하는 핵심 keyword

template <typename T>
void change(T& a, T& b) 
{
	T temp{ a };
	a = b;
	b = temp;
}

int main()
{
	Dog a, b;
	change(a, b);
	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-12-12 오후 6:29:40 - (토요일)
//-------------------------------------------------------------------------

//--------------------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 23일 (12주 1일)

상속
	1. 코드를 재사용하려고 이용한다
	2. 다형성을 구현한다

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

class 부모 {
	int 부모정수;	// 4바이트

public:
	void set부모정수(int n) {
		부모정수 = n;
	}

	int get부모정수() const {
		return 부모정수;
	}
};

class 자식 : public 부모 { 
	int 자식정수;	// 4바이트

public:
	자식() { 
		자식정수 = 456;
		set부모정수(123);
	}

	friend ostream& operator<<(ostream&, const 자식&);
};

ostream& operator << (ostream& os, const 자식& child) {
	cout << "[부모정수-" << child.get부모정수() << "],[자식정수-" << child.자식정수 << "]" << endl;
	return os;
}

// [문제] main()을 수정하지 않고 (class는 변경가능)
// 요구하는 출력이 나오도록 하자

int main()
{
	자식 child;		// [부모정수] + [자식정수] = 8
					// -> 자식() -> [123][456]

	cout <<	sizeof(child) << endl;

	cout << child << endl;		// [부모정수-123],[자식정수-456]

	save("소스.cpp");
}





//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-12-12 오후 6:32:30 - (토요일)
//-------------------------------------------------------------------------

//--------------------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 23일 (12주 1일)

상속
	1. 코드를 재사용하려고 이용한다
	2. 다형성을 구현한다

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

class 부모 {
protected:			// 이 멤버는 자식이 자신의 private 멤버처럼 사용가능
	int 부모정수;
};

class 자식 : public 부모 { 
	int 자식정수;

public:
	자식() { 
		자식정수 = 456;
		부모정수 = 123;
		
	}

	friend ostream& operator<<(ostream&, const 자식&);
};

ostream& operator << (ostream& os, const 자식& child) {
	cout << "[부모정수-" << child.부모정수 << "],[자식정수-" << child.자식정수 << "]" << endl;
	return os;
}

// [문제] main()을 수정하지 않고 (class는 변경가능)
// 요구하는 출력이 나오도록 하자

int main()
{
	자식 child;		// [부모정수] + [자식정수] = 8
					// -> 자식() -> [123][456]

	cout <<	sizeof(child) << endl;

	cout << child << endl;		// [부모정수-123],[자식정수-456]

	save("소스.cpp");
}





//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-12-12 오후 6:42:15 - (토요일)
//-------------------------------------------------------------------------

//--------------------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 23일 (12주 1일)

상속
	1. 코드를 재사용하려고 이용한다
	2. 다형성을 구현한다

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

class Animal {
protected:
	int a;

public:
	Animal() {
		cout << "Animal 생성" << endl;
	}

	~Animal() {
		cout << "Animal 소멸" << endl;
	}
};

class Dog : public Animal {
	int d;
public:
	Dog(int a, int b) {
		Animal::a = a;
		d = b;
		cout << "Dog 생성" << endl;
	}

	~Dog() {
		cout << "Dog 소멸" << endl;
	}

	friend ostream& operator<<(ostream& os, const Dog& dog);
};

ostream& operator<<(ostream& os, const Dog& dog) 
{
	os << "dog - " << dog.a << ", " << dog.d << endl;
	return os;
}

// [문제] main을 바꾸지 말고 원하는 결과가 나오도록 class를 코딩한다
// * 이때 객체의 생성과 소멸을 관찰하시오

int main()
{
	Dog dog{ 123, 456 };	// 이때 생성자를 호출할 수 있다 [][]

	cout << dog << endl;	// dog - 123, 456

	save("소스.cpp");
}





//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-12-12 오후 6:46:25 - (토요일)
//-------------------------------------------------------------------------

//--------------------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 23일 (12주 1일)

상속
	1. 코드를 재사용하려고 이용한다
	2. 다형성을 구현한다

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

class Animal {
protected:
	int a;

public:
	Animal() {
		cout << "Animal 생성" << endl;
	}

	~Animal() {
		cout << "Animal 소멸" << endl;
	}
};

class Dog : public Animal {
	int d;
public:
	Dog(int a, int b) {
		Animal::a = a;
		d = b;
		cout << "Dog 생성" << endl;
	}

	~Dog() {
		cout << "Dog 소멸" << endl;
	}

	friend ostream& operator<<(ostream& os, const Dog& dog);
};

ostream& operator<<(ostream& os, const Dog& dog) 
{
	os << "dog - " << dog.a << ", " << dog.d << endl;
	return os;
}

// [문제] main을 바꾸지 말고 원하는 결과가 나오도록 class를 코딩한다
// * 이때 객체의 생성과 소멸을 관찰하시오

int main()
{
	{
		new Dog{ 123, 456 };	// new로 만들면 소멸되지 않음
	}
	
	//cout << dog << endl;	// dog - 123, 456

	save("소스.cpp");
}





//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-12-12 오후 6:47:19 - (토요일)
//-------------------------------------------------------------------------

//--------------------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 23일 (12주 1일)

상속
	1. 코드를 재사용하려고 이용한다
	2. 다형성을 구현한다

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

class Animal {
protected:
	int a;

public:
	Animal() {
		cout << "Animal 생성" << endl;
	}

	~Animal() {
		cout << "Animal 소멸" << endl;
	}
};

class Dog : public Animal {
	int d;
public:
	Dog(int a, int b) {
		Animal::a = a;
		d = b;
		cout << "Dog 생성" << endl;
	}

	~Dog() {
		cout << "Dog 소멸" << endl;
	}

	friend ostream& operator<<(ostream& os, const Dog& dog);
};

ostream& operator<<(ostream& os, const Dog& dog) 
{
	os << "dog - " << dog.a << ", " << dog.d << endl;
	return os;
}

// [문제] main을 바꾸지 말고 원하는 결과가 나오도록 class를 코딩한다
// * 이때 객체의 생성과 소멸을 관찰하시오

int main()
{
	Dog* dog = new Dog{ 123123, 456456 };	// new로 만들면 소멸되지 않음
	
	cout << *dog << endl;	// dog - 123, 456

	save("소스.cpp");

	delete dog;
}





//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-12-12 오후 7:02:25 - (토요일)
//-------------------------------------------------------------------------

//--------------------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 23일 (12주 1일)

상속
	1. 코드를 재사용하려고 이용한다
	2. 다형성을 구현한다

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// [문제] 다음을 class로 만들어 보세요.
// Animal은 모두 이름이 있다. 모두 move() 할 수 있다.
// Dog는 Animal이다.
// Bird도 Animal이다.

class Animal {
protected:
	string name;

public:
	Animal() = default;

	Animal(string s) : name{ s } {	};

	void move() {
		cout << name << "가 움직인다" << endl;
	}
};

class Dog : public Animal {
public:
	Dog(string s) : Animal{ s } {
	}
};

class Bird : public Animal { 
public:
	Bird(string s) {
		name = s;
	}
};

int main()
{
	Dog dog{ "댕댕이" };		// [24] 0
	Bird bird{ "짹짹이" };		// [24] 0

	dog.move();		// 댕댕이가 움직인다
	bird.move();	// 짹짹이가 움직인다

	save("소스.cpp");
}





//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-12-12 오후 8:07:29 - (토요일)
//-------------------------------------------------------------------------

//--------------------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 23일 (12주 1일)

상속
	1. 코드를 재사용하려고 이용한다
	2. 다형성을 구현한다

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// 다형성(polymorphism)이란?
// One interface - Multiple behavior (단일명령 - 다중행동)
// 다수의 서로 다른 종류의 객체를 하나로 묶어 관리할 수 있어야 한다

// 상속관계에서 언제나 참인 관계
// sizeof(Animal) <= sizeof(Dog)

class Animal {
	int a;

public:
	void move() {
		cout << "Animal의 move()" << endl;
	}
};

class Dog : public Animal {
	int d;

public:
	void move() {
		cout << "Dog의 move()" << endl;
	}
};

int main()
{	
	Animal a;			// [a]
	Dog d;				// [a][d]

	a.move();
	d.move();

	save("소스.cpp");
}





//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-12-12 오후 8:17:49 - (토요일)
//-------------------------------------------------------------------------

//--------------------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 23일 (12주 1일)

상속
	1. 코드를 재사용하려고 이용한다
	2. 다형성을 구현한다

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// 다형성(polymorphism)이란?
// One interface - Multiple behavior (단일명령 - 다중행동)
// 다수의 서로 다른 종류의 객체를 하나로 묶어 관리할 수 있어야 한다

// 상속관계에서 언제나 참인 관계
// sizeof(Animal) <= sizeof(Dog)

class Animal {
	int a;

public:
	void move() {
		cout << "Animal의 move()" << endl;
	}
};

class Dog : public Animal {
	int d;

public:
	void move() {
		cout << "Dog의 move()" << endl;
	}
};

int main()
{	
	Animal a;			// [a]
	Dog d;				// [a][d]

	// Dog의 메모리에는 언제나 Animal의 메모리가 포함된다

	Dog* pd = &d;
	pd->move();			// dog.move()와 같은 결과

	Animal* pa = &d;
	pa->move();			// 자료형이 조상(Animal)이기 때문에 Animal.move()가 나옴

	save("소스.cpp");
}





//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-12-12 오후 8:22:02 - (토요일)
//-------------------------------------------------------------------------

//--------------------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 23일 (12주 1일)

상속
	1. 코드를 재사용하려고 이용한다
	2. 다형성을 구현한다

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// 다형성(polymorphism)이란?
// One interface - Multiple behavior (단일명령 - 다중행동)
// 다수의 서로 다른 종류의 객체를 하나로 묶어 관리할 수 있어야 한다

// 상속관계에서 언제나 참인 관계
// sizeof(Animal) <= sizeof(Dog)

class Animal {
	int a;

public:
	// 진짜 함수를 찾아 호출하고 싶다면 그 함수 앞에 virtual을 붙인다.
	virtual void move() {
		cout << "Animal의 move()" << endl;
	}
};

class Dog : public Animal {
	int d;

public:
	void move() {
		cout << "Dog의 move()" << endl;
	}
};

int main()
{	
	Animal a;			// [a]
	Dog d;				// [a][d]

	// Dog의 메모리에는 언제나 Animal의 메모리가 포함된다

	Animal* pa = &d; // 부모인 Animal 포인터로 자식인 Dog를 가리킨다
					 // Animal의 모든 자식 객체들을 Animal*로 가리킬 수 있다

	pa->move();		// 다형성이 구현되도록 하고 싶다. (dog.move())가 되도록.

	save("소스.cpp");
}





//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-12-12 오후 8:25:45 - (토요일)
//-------------------------------------------------------------------------

//--------------------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 23일 (12주 1일)

상속
	1. 코드를 재사용하려고 이용한다
	2. 다형성을 구현한다

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// 다형성(polymorphism)이란?
// One interface - Multiple behavior (단일명령 - 다중행동)
// 다수의 서로 다른 종류의 객체를 하나로 묶어 관리할 수 있어야 한다

// 상속관계에서 언제나 참인 관계
// sizeof(Animal) <= sizeof(Dog)

class Animal {
	int a;

public:
	// 진짜 함수를 찾아 호출하고 싶다면 그 함수 앞에 virtual을 붙인다.
	// C++에서 다형성을 구현하는 핵심 키워드 virtual

	virtual void move() {
		cout << "Animal의 move()" << endl;
	}
};

class Dog : public Animal {
	int d;

public:
	void move() {
		cout << "Dog의 move()" << endl;
	}
};

int main()
{	
	Animal a;			// [a]
	Dog d;				// [a][d]

	// virtual이 있는 상황
	cout << "Animal의 크기 - " << sizeof(Animal) << endl;	// 8바이트 (virtual로 4바이트 증가됨)
	cout << "Dog의 크기 - " << sizeof(Dog) << endl;			// 12바이트	(virtual로 4바이트 증가됨)

	Animal* pa = &d;

	pa->move();

	save("소스.cpp");
}





//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-12-12 오후 8:27:19 - (토요일)
//-------------------------------------------------------------------------

//--------------------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 23일 (12주 1일)

상속
	1. 코드를 재사용하려고 이용한다
	2. 다형성을 구현한다

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// 다형성(polymorphism)이란?
// One interface - Multiple behavior (단일명령 - 다중행동)
// 다수의 서로 다른 종류의 객체를 하나로 묶어 관리할 수 있어야 한다

// 상속관계에서 언제나 참인 관계
// sizeof(Animal) <= sizeof(Dog)

class Animal {
	int a;

public:
	// 진짜 함수를 찾아 호출하고 싶다면 그 함수 앞에 virtual을 붙인다.
	// C++에서 다형성을 구현하는 핵심 키워드 virtual
	//만들어지는 모든 객체마다 포인터 하나가 추가된다.(포인터 하나의 메모리만큼 늘어남)

	virtual void move() {
		cout << "Animal의 move()" << endl;
	}
};

class Dog : public Animal {
	int d;

public:
	void move() {
		cout << "Dog의 move()" << endl;
	}
};

int main()
{	
	Animal a;			// [a]
	Dog d;				// [a][d]

	// virtual이 있는 상황
	cout << "Animal의 크기 - " << sizeof(Animal) << endl;	// 8바이트 (virtual로 4바이트 증가됨)
	cout << "Dog의 크기 - " << sizeof(Dog) << endl;			// 12바이트	(virtual로 4바이트 증가됨)

	Animal* pa = &d;

	pa->move();

	save("소스.cpp");
}





//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-12-12 오후 8:32:11 - (토요일)
//-------------------------------------------------------------------------

//--------------------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 23일 (12주 1일)

상속
	1. 코드를 재사용하려고 이용한다
	2. 다형성을 구현한다

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// 다형성(polymorphism)이란?
// One interface - Multiple behavior (단일명령 - 다중행동)
// 다수의 서로 다른 종류의 객체를 하나로 묶어 관리할 수 있어야 한다

// 상속관계에서 언제나 참인 관계
// sizeof(Animal) <= sizeof(Dog)

class Animal {
public:
	// 진짜 함수를 찾아 호출하고 싶다면 그 함수 앞에 virtual을 붙인다.
	// C++에서 다형성을 구현하는 핵심 키워드 virtual
	//만들어지는 모든 객체마다 포인터 하나가 추가된다.(포인터 하나의 메모리만큼 늘어남)
	virtual void move() {
		cout << "Animal의 move()" << endl;
	}
};

class Dog : public Animal {
public:
	void move() {
		cout << "Dog의 move()" << endl;
	}
};

class Bird : public Animal {
public:
	void move() {
		cout << "Bird의 move()" << endl;
	}
};

int main()
{	
	Dog dog;
	Bird bird;

	Animal* animals[2];

	animals[0] = &dog;
	animals[1] = &bird;
	
	for (Animal* 동물 : animals)
		동물->move();

	save("소스.cpp");
}





//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-12-12 오후 8:44:33 - (토요일)
//-------------------------------------------------------------------------

//--------------------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 23일 (12주 1일)

상속
	1. 코드를 재사용하려고 이용한다
	2. 다형성을 구현한다

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// 다형성(polymorphism)이란?
// One interface - Multiple behavior (단일명령 - 다중행동)
// 다수의 서로 다른 종류의 객체를 하나로 묶어 관리할 수 있어야 한다

	// 진짜 함수를 찾아 호출하고 싶다면 그 함수 앞에 virtual을 붙인다.
	// C++에서 다형성을 구현하는 핵심 키워드 virtual
	//만들어지는 모든 객체마다 포인터 하나가 추가된다.(포인터 하나의 메모리만큼 늘어남)


int main()
{	
	// 함수는 CODE 세그먼트에 있다.
	cout << "main 함수의 번지 - " << &main << endl;
	cout << "save 함수의 번지 - " << &save << endl;
	cout << "printf 함수의 번지 - " << &printf << endl;

	printf("이것은 시험입니다\n");

	save("소스.cpp");
}





//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-12-12 오후 8:45:05 - (토요일)
//-------------------------------------------------------------------------

//--------------------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 23일 (12주 1일)

상속
	1. 코드를 재사용하려고 이용한다
	2. 다형성을 구현한다

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// 다형성(polymorphism)이란?
// One interface - Multiple behavior (단일명령 - 다중행동)
// 다수의 서로 다른 종류의 객체를 하나로 묶어 관리할 수 있어야 한다

	// 진짜 함수를 찾아 호출하고 싶다면 그 함수 앞에 virtual을 붙인다.
	// C++에서 다형성을 구현하는 핵심 키워드 virtual
	//만들어지는 모든 객체마다 포인터 하나가 추가된다.(포인터 하나의 메모리만큼 늘어남)


int main()
{	
	// 함수는 CODE 세그먼트에 있다.
	cout << "main 함수의 번지 - " << &main << endl;
	
	int n;
	cout << "스택의 번지 - " << &n << endl;
	
	save("소스.cpp");
}





//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-12-12 오후 8:51:41 - (토요일)
//-------------------------------------------------------------------------

//--------------------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 23일 (12주 1일)

상속
	1. 코드를 재사용하려고 이용한다
	2. 다형성을 구현한다

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// 다형성(polymorphism)이란?
// One interface - Multiple behavior (단일명령 - 다중행동)
// 다수의 서로 다른 종류의 객체를 하나로 묶어 관리할 수 있어야 한다

class Animal {
public:
	virtual void move() {
		cout << "Animal - move()" << endl;
	}
};

class Dog : public Animal {
public:
	void move() {
		cout << "Dog - move()" << endl;
	}
};

int main()
{	
	// 함수는 CODE 세그먼트에 있다.
	cout << "main 함수의 번지 - " << &main << endl;
	
	Dog dog;		// move가 virtual이므로 vptr이 멤버에 추가된다
					// 그래서 dog의 크기는 4바이트이다

	int* p = (int*)&dog;
	cout << "vtbl의 주소 - " << (void*)* p << endl;	// vptr에 적힌 vtbl의 주솟값(주솟값이라 void* 형식)

	save("소스.cpp");
}





//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-12-12 오후 9:01:20 - (토요일)
//-------------------------------------------------------------------------

//--------------------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 23일 (12주 1일)

상속
	1. 코드를 재사용하려고 이용한다
	2. 다형성을 구현한다

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// 다형성(polymorphism)이란?
// One interface - Multiple behavior (단일명령 - 다중행동)
// 다수의 서로 다른 종류의 객체를 하나로 묶어 관리할 수 있어야 한다

class Animal {
public:
	virtual void move() {
		cout << "Animal - move()" << endl;
	}
};

class Dog : public Animal {
public:
	void move() {
		cout << "Dog - move()" << endl;
	}
};

int main()
{	
	// 함수는 CODE 세그먼트에 있다.
	cout << "main 함수의 번지 - " << &main << endl;
	
	Dog dog;		// move가 virtual이므로 vptr이 멤버에 추가된다
					// 그래서 dog의 크기는 4바이트이다

	int* p = (int*)&dog;
	cout << "vtbl의 주소 - " << (void*)(*p) << endl;	// *p에는 int의 주소값이 저장되어 있음
	int* pp = (int*)(*p);
	cout << "vtbl에 기록된 move 함수의 시작번지 - " << (void*)(*pp) << endl;

	save("소스.cpp");
}




//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-12-12 오후 9:06:09 - (토요일)
//-------------------------------------------------------------------------

//--------------------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 23일 (12주 1일)

상속
	1. 코드를 재사용하려고 이용한다
	2. 다형성을 구현한다

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// 다형성(polymorphism)이란?
// One interface - Multiple behavior (단일명령 - 다중행동)
// 다수의 서로 다른 종류의 객체를 하나로 묶어 관리할 수 있어야 한다

class Animal {
public:
	virtual void move() {
		cout << "Animal - move()" << endl;
	}

	virtual void x() {
		cout << "Animal - x()" << endl;
	}
};

class Dog : public Animal {
public:
	void move() {
		cout << "Dog - move()" << endl;
	}
};

int main()
{	
	// 함수는 CODE 세그먼트에 있다.
	cout << "main 함수의 번지 - " << &main << endl;
	
	Dog dog;		// move가 virtual이므로 vptr이 멤버에 추가된다
					// 그래서 dog의 크기는 4바이트이다

	int* p = (int*)&dog;
	cout << "vtbl의 주소 - " << (void*)(*p) << endl;	// *p에는 int의 주소값이 저장되어 있음
	int* pp = (int*)(*p);
	cout << "vtbl에 기록된 move 함수의 시작번지 - " << (void*)(*pp) << endl;

	void (*fp) () = (void(*)())(*pp);

	fp();

	save("소스.cpp");
}





//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-12-12 오후 9:07:15 - (토요일)
//-------------------------------------------------------------------------

//--------------------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 23일 (12주 1일)

상속
	1. 코드를 재사용하려고 이용한다
	2. 다형성을 구현한다

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// 다형성(polymorphism)이란?
// One interface - Multiple behavior (단일명령 - 다중행동)
// 다수의 서로 다른 종류의 객체를 하나로 묶어 관리할 수 있어야 한다

class Animal {
public:
	virtual void move() {
		cout << "Animal - move()" << endl;
	}

	virtual void x() {
		cout << "Animal - x()" << endl;
	}
};

class Dog : public Animal {
public:
	void move() {
		cout << "Dog - move()" << endl;
	}
};

int main()
{	
	// 함수는 CODE 세그먼트에 있다.
	cout << "main 함수의 번지 - " << &main << endl;
	
	Dog dog;		// move가 virtual이므로 vptr이 멤버에 추가된다
					// 그래서 dog의 크기는 4바이트이다

	int* p = (int*)&dog;
	cout << "vtbl의 주소 - " << (void*)(*p) << endl;	// *p에는 int의 주소값이 저장되어 있음
	int* pp = (int*)(*p);
	cout << "vtbl에 기록된 move 함수의 시작번지 - " << (void*)(*pp) << endl;

	void (*fp) () = (void(*)())(*pp);
	fp();

	pp++;
	fp = (void(*)())(*pp);
	fp();

	save("소스.cpp");
}




//--------------------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 23일 (12주 1일)

상속
	1. 코드를 재사용하려고 이용한다
	2. 다형성을 구현한다

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// 다형성(polymorphism)이란?
// One interface - Multiple behavior (단일명령 - 다중행동)
// 다수의 서로 다른 종류의 객체를 하나로 묶어 관리할 수 있어야 한다


int main()
{	
	void* p = &main;

	int (*x)() = (int(*)())p;
	
	cout << "메인 --------------------- " << endl;		// 무한루프
	
	x();

	save("소스.cpp");
}





//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-12-12 오후 9:26:21 - (토요일)
//-------------------------------------------------------------------------

//--------------------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 23일 (12주 1일)

상속
	1. 코드를 재사용하려고 이용한다
	2. 다형성을 구현한다

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"
using namespace std;

// [문제] 사용자 입력을 받아 동물을 생성한다.
// 1. 몇 마리를 만들지 물어본다.
// 2. 원하는대로 동물을 생성한다. (랜덤값이 홀수이면 Dog, 짝수이면 Bird)
// 3. 모든 동물의 move()를 실행한다.
// 1~3 과정이 무한 반복될 수 있어야 한다.

class Animal {
public:
	virtual void move() const = 0;
};

class Dog : public Animal {
public:
	virtual void move() const override {
		cout << " <<<<<< 개가 달린다 " << endl;
	}
};

class Bird : public Animal {
public:
	virtual void move() const override {
		cout << " ~~~~~ 새가 난다 ~~~~~" << endl;
	}
};

default_random_engine dre;
int main()
{	
	char quit;
	while ( quit != 'q' ) {
		int num;

		cout << "몇 마리를 생성할까요? ";
		cin >> num;

		auto animals = new Animal * [num];	// auto = Animal**

		uniform_int_distribution<> uid{ 0, 1 };

		for (int i = 0; i < num; ++i) {
			if (uid(dre) == 1)
				animals[i] = new Dog;
			else
				animals[i] = new Bird;
		}

		for (int i = 0; i < num; ++i)
			animals[i]->move();

		for (int i = 0; i < num; ++i)
			delete animals[i];

		delete[] animals;

		cout << "그만하고 싶으면 q를 입력해 주세요";
		cin >> quit;
	}

	save("소스.cpp");
}





//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-12-12 오후 10:10:48 - (토요일)
//-------------------------------------------------------------------------

//--------------------------------------------------------------------------
/* 2020년 2학기 C++                                     11월 30일 (13주 1일)

상속
	1. 코드를 재사용하려고 이용한다
	2. 다형성을 구현한다

시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"
using namespace std;

// [문제] 사용자 입력을 받아 동물을 생성한다.
// 1. 몇 마리를 만들지 물어본다.
// 2. 원하는대로 동물을 생성한다. (랜덤값이 홀수이면 Dog, 짝수이면 Bird)
// 3-1. 동물 중에서 Dog만 move()를 실행한다.

// 1~3 과정이 무한 반복될 수 있어야 한다.

class Animal {
public:
	virtual void move() const = 0;

	// 만일 부모 클래스인 Animal이 객체 생성 시 자원을 획득했다면
	// Animal은 소멸자에서 획득한 자원을 반환할 것이다.
	// 그렇다면 반드시 소멸자를 virtual로 선언해야만 모든 자원이
	// 제대로 소멸된다

	virtual ~Animal() {	}
};

class Dog : public Animal {
public:
	virtual void move() const override {
		cout << " <<<<<< 개가 달린다 " << endl;
	}
};

class Bird : public Animal {
public:
	virtual void move() const override {
		cout << " ~~~~~ 새가 난다 ~~~~~" << endl;
	}
};

default_random_engine dre;
int main()
{	
	char again = 'a';
	while ( again == 'a' ) {
		int num;

		cout << "몇 마리를 생성할까요? ";
		cin >> num;

		auto animals = new Animal* [num];	// auto = Animal**

		uniform_int_distribution<> uid{ 0, 1 };

		for (int i = 0; i < num; ++i) {
			if (uid(dre) == 1)
				animals[i] = new Dog;
			else
				animals[i] = new Bird;
		}

		for (int i = 0; i < num; ++i) {
			// if ( animals[i]가 가리키는 동물이 원래는 Dog였다면 )
			// RTTI 
			if ( dynamic_cast<Dog*>(animals[i]) ) {
				animals[i]->move();
			}
		}

		for (int i = 0; i < num; ++i)
			delete animals[i];

		delete[] animals;

		cout << "다시 하고 싶으면 a를 입력해 주세요";
		cin >> again;
	}

	save("소스.cpp");
}





//-------------------------------------------------------------------------
[ 소스.cpp ] - 2020-12-14 오후 2:09:38 - (월요일)
//-------------------------------------------------------------------------

//--------------------------------------------------------------------------
/* 2020년 2학기 C++                                     12월 14일 (15주 1일)


시험 3. 12월 16일 수요일 (15주 2일) */
 //-------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"
using namespace std;


class Test {
	int* p;

	Test() {
		p = new int[10];
	}

	~Test();
	Test(const Test&);
	Test& operator=(const Test&);
};

int main()
{	

	save("소스.cpp");
}
